{"layout": "post", "title": "Blog Fullstack", "published": "May 04, 2021", "author": "yonatan119", "tags": "node, js, javascript, express, mongodb, react", "timestamp": 1620135034, "location": "blog.md.json", "content": "Project Setup\n- Create a directory for your project and cd into it\n```javascript\n mkdir mern-blog && cd mern-blog\n```\nStructure\n- server.js - JS file\n- models - Folder\n  - article.js\n- routes - File\n  - index.js\n___\n**Package.json**\nGenerate a package.json file. This file contains the metadata for a Node.js project. Adding the --yes flag will use the defaults for the fields.\n```javascript\nnpm init -y\n```\nPackages:\n- express\n- mongoose\n```javascript\nnpm install express mongoose\n```\nYour package.json file should look something like the below. A list of the project's installed packages with version is saved under dependencies.  \nIf we ran npm install then npm would attempt to install or update the packages listed there.  \nMake sure the \"main\" property's value is \"server.js\". Change it if it isn't.  \nAlso make sure you have the \"start\" script. Add it if you don't.  \nWe can run the commands in the scripts object from the command line with \n```javascript\nnpm run script-name\n```\nI'll explain more in the next section.\n```javascript\n//package.json\n{\n  \"name\": \"mern-blog\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Web app built with Node.js, Express, MongoDB, and React\",\n  \"main\": \"server.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"node server.js\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.17.1\",\n    \"mongoose\": \"^5.6.6\"\n  }\n}\n```\nYou will also see a file named package-lock.json.  \nThat lists all the project's installed packages with their versions and their dependencies.\n___\n**Express Web Framework**\n*Server.js*\nPopulate the server.js file with a hello world app powered by Express:\n```javascript\n// server.js\nconst express = require('express');\nconst app = express();\nconst PORT = 3001;\n\napp.get('/', function(request, response) { response.send('Hello World!') });\n\napp.listen(PORT, function() { console.log(`Server listening on port ${PORT}`) });\n```\nThis simple file, with the Express library, will create a server.  \nThere are a few different commands you can use to run it. I'll cover them briefly.  \n\n- First there is a standard node command to execute any file:\n***node server.js*** or just ***node server***\nThis should log \"Server listening on port 3001\" in the terminal, and if you open a browser to localhost:3001 you should get \"hello world\". To stop the server, from the terminal press CTRL+C,\n\n- NPM init generated a script to run this command in our package.json file. You call the scripts in your package.json file with npm run script-name or in a few cases \"run\" is optional.  \n***npm start***  \n\n- The third way to execute the server.js file is to use the nodemon command. We installed nodemon for hot reloading. To use it just enter nodemon and it looks for a file named server.js to run by default. This is the command we'll use throughout this project.\n```javascript\nnodemon\n```\nA quick note on syntax. Node recognizes most, but not all, ES6 syntax. Notably it does not recognize import/export statements, so we won't use them here. You have the option of installing Babel which will translate it for you. Since it's not critical to this project we won't do it. Also, as default I am using the declaration syntax for functions rather than arrow functions. That just makes it consistently explicit what your function is returning or if it isn't returning anything.\n___\n**MongoDB database**\nMongoDB offers a cloud database called Atlas, or you can download the \"community version\" on your local machine. You may want to use mlabs like in our previous projects but it will be good to practice different ways. Which to use? I generally prefer a local version to work with in development. Sometimes there are connection issues with a cloud version (which I ran into). But if you deploy your app then you need a cloud solution. I will explain both ways.\n*Reminders*\n\"Collections\" are like tables in a relational database and \"documents\" are like records.\nAlso, don't worry about creating the collections. Once you create the database and connect to it, MongoDB will automatically create a collection for you when you save a document to a collection that doesn't exist yet.\n___\n**Option 1) MongoDB Atlas**\nAt the time of this writing you can set up a free account for a small project like this one at mongodb.com/cloud/atlas. It is very fast and straight-forward to set up. Just follow their steps, but note a few things:\n\n- It will ask you for a name and password for the project. You will use these to access the database.\n- In one of the steps they will ask you to whitelist the IP addresses that will be accessing your database. For a practice app like this just click on \"add IP\" and select the \"Allow access from anywhere\" option.\n- Skip seeding the database.\n- For the last step you select a connect option. We want the \"Connect your application\" option. That will provide you with a link to add to your application. Something like\n```javascript\nmongodb+srv://user:password@cluster-number.mongodb.net/test?retryWrites=true&w=majority\n```\nCopy this and paste it into the server.js file (which we'll cover next).\n___\n**Option 2) MongoDB local \"community\" version**\nin case it is not installed yet, installation instructions are at docs.mongodb.com/manual/project/install-mongodb-on-windows.\nOnce it's installed you run MongoDB from the terminal (from any directory) and have to leave that window open and running to access the database:\n```javascript\nmongod\n```\nStop MongoDB from the same terminal window with CTRL+C.\n\n**MongoDB Shell**\nYou can interact with the database directly using the MongoDB shell from the Terminal. There are also GUI tools like Robo T3 if you prefer that but frankly for small projects I find the command line easier to work with. To use the shell from anywhere in the terminal run:\n\n**Mongoose ORM**\nWe installed the mongoose package in our app. Just a reminder, Mongoose is a middleware library that performs the Object Relational Mapping (ORM) between our Express application and MongoDB. In essence it does the translations allowing them to talk to each other.\nWe'll start by using Mongoose to connect to MongoDB in our server file. Let's replace the hello world response with our real code and then we'll go through it line by line.\nTry by yourself first.  \n- Start by importing our express and mongoose packages and our Express router which we'll define shortly.\n- Calling the express() function will create our running app object.\n- The Express listen method called at the bottom of our file uses 3000 as it's default port for it's server. We'll declare a new PORT constant to give us the flexibility to use different ports depending on whether we are in development or production.\n- Assigning constants for things like port number and the database URL gives us the flexibility to change the values in one place.\nIf you are using the MongoDB Atlas cloud database then paste the link there.\nIf you are using the local version, MongoDB is accessed through localhost on port 27017 by default, and the path is the database name. We'll just call ours my_local_db.\n- Chaining Express's use method to our app object gives us access to the libraries we imported. express.urlencoded({ extended: true }) and express.json() are middleware for parsing requests with JSON payloads (for POST and PATCH/PUT requests).\n- Apply the Express router object to your Express app. I'll explain this in the routing section.\n- mongoose.connect() connects to our MongoDB database\n- Optionally, log a message if the above connection was successful and one if it is not.\n- Chain the Express listen method to our app. This will listen for connections on the specified port.\n\n```javascript\n// server.js\nconst express = require('express'); \nconst mongoose = require('mongoose');\n// const cors = require('cors');\nconst router = require('./routes/index');\n\nconst app = express(); \nconst PORT = 3001; \nconst MONGODB_URI = \"mongodb://localhost:27017/my_local_db\"; \n\n// app.use(cors())\napp.use(express.urlencoded({ extended: true })); \napp.use(express.json());\napp.use('/api', router); \n\nmongoose.connect(MONGODB_URI, { useNewUrlParser: true, useFindAndModify: false }); \nmongoose.connection.once('open', function() { \n  console.log('Connected to the Database.');\n});\nmongoose.connection.on('error', function(error) {\n  console.log('Mongoose Connection Error : ' + error);\n});\n\napp.listen(PORT, function() { \n  console.log(`Server listening on port ${PORT}.`);\n});\n```\n___\n**Cors**\nLet's talk briefly about Cross-Origin Resource Sharing (CORS).  \nBy default Express will block cross-origin HTTP requests for security reasons.  \nCross-origin means the request is from a different origin (domain, protocol, and/or port) than its own origin.  \nOur API is served on localhost port 3001, if our API is accessed by mobile apps for example they will be on a different origin and any requests will be rejected.  \nThere is an npm package called cors that will apply additional HTTP headers to tell the browser to allow access from a specified origin or any origin.\n\nA standard MERN app is really an integrated single web application even if the back end and front end run independently.  \nWe only want to give access to the integrated front end (our React client in this case) and therefore won't use the cors package.  \nThere's an additional step when we build the React app that we'll cover there.\n\nIf, however, your API is meant to be accessed by mobile apps or other websites then you need to install the cors middleware package and connect it to your app.\n```javascript\nnpm install cors\n```\nThe server.js file comments out the cors package import and where it is applied to the app, to allow cross origin access uncomment those lines.  \nFor more on the CORS concept see developer.mozilla.org/en-US/docs/Web/HTTP/CORS\n___\n**Schema and Model**\nPopulate the model file with the below:\n```javascript\n// models/article.js\nconst mongoose = require('mongoose');\n\nconst articleSchema = new mongoose.Schema({ \n  title: {\n    type: String,\n    required: [true, \"Title is required\"]\n  },\n  content: {\n    type: String,\n    required: [true, \"Content can't be blank\"]\n  }\n});\n\nmodule.exports = mongoose.model('Article', articleSchema); \n```\n- A database schema is it's structure, the mongoose schema is a prototype that maps to a MongoDB collection and defines the shape of the documents within that collection.  \nHere we are creating an instance of mongoose.Schema that defines two fields with type set to String and making them required.  \nRead about Mongoose Schema at mongoosejs.com/docs/guide.html.\n- Models represent the data in an application, a mongoose model is a constructor function that creates and reads documents to and from the underlying MongoDB database.  \nThe first argument is the singular uppercase name of your database collection.  \nSo Article represents the articles MongoDB collection.  \nThe second argument is the schema which we defined above.  \nAn individual article is an instance of the Article model.\n___\n**Routes**\nNow that we have our server, database and model set up, the last step for our simple API application is routing.  \nRouting refers to determining how an application responds to a client request to a particular endpoint. An endpoint is a combined URI and HTTP request method (GET, POST, PATCH or PUT, DELETE) that activates specific actions from our API.\n\nWe will apply database Create, Read, Update, and Delete (CRUD) actions to each endpoint.  \nMeaning we will have an endpoint to return (Read) a JSON array of all our articles and another endpoint to return (Read) a JSON object for a specified article id.  \nWe will also have endpoints to Create, Update, and Delete articles, so our routes will be \"RESTful\" which essentially means our application routes and actions are built around performing these database CRUD actions.  \nPopulate the routes file:\n___\nSteps:\n- Create an instance of the Express Router to be used as middleware for our routes.\n- Import the Article model.\n- For each API endpoint we will chain a method to the router object. The format is:\n```javascript\nrouter.HTTP Method(path, handler function)\n```\nWe will import the Article model representing the articles collection in our database.  \nWe chain methods from the mongoose library to the Article prototype that will perform different types of CRUD actions.  \nOur handler functions perform the CRUD operation and may return a response.  \nGenerally only return responses that will be used by the client.\n- Get request to /articles returns a JSON array of all article objects found in the database.\n- Get request to /articles/:id (:id is a variable representing an article's _id) returns a JSON object of the specified article if it exists, otherwise returns status 404 and \"No result found\"\n- Post request to /articles creates a new Article instance from the JSON object in sent in the HTTP request body and saves it to the database.  \nIf successful a status 200 code is automatically returned. We'll add on to that a JSON response with the new article object we just added which includes the article _id generated by the database.\n- Patch request to /articles/:id updates the specified article with the JSON object sent in the HTTP request body. You could use the PATCH, PUT or POST HTTP methods since they all send a payload. It's the handler function that determines what is done with the payload. On a successful update we are returning a JSON response just stating \"Article updated\". If the article did not update then we send an Unprocessable Entity code 422 response with a message.\n- Delete request to /articles/:id first checks if the article exists. If so it deletes it and sends status 200 with a JSON response of \"Article deleted\".\n- Export the router object with our Article endpoints.\nTry it out yourself before going down.\n```javascript\n// routes/index.js\nconst express = require ('express'); \nconst router = express.Router(); \nconst Article = require('../models/article'); \n\nrouter.get('/articles', function(req, res) { \n  Article.find(function(err, articles) {\n    res.json(articles);\n  });\n});\n\nrouter.get('/articles/:id', function(req, res) {  \n  Article.findById(req.params.id, function(err, article) {\n    if (!article) {\n      res.status(404).send('No result found');\n    } else {\n      res.json(article);\n    }\n  });\n});\n\nrouter.post('/articles', function(req, res) {     \n  let article = new Article(req.body);\n  article.save()\n    .then(article => {\n      res.send(article);\n    })\n    .catch(function(err) {\n      res.status(422).send('Article add failed');\n    });\n});\n\nrouter.patch('/articles/:id', function(req, res){    \n  Article.findByIdAndUpdate(req.params.id, req.body)\n    .then(function() {\n      res.json('Article updated');\n    })\n    .catch(function(err) {\n      res.status(422).send(\"Article update failed.\");\n    });\n});\n\nrouter.delete('/articles/:id', function(req, res) {  \n  Article.findById(req.params.id, function(err, article) {\n    if (!article) {\n      res.status(404).send('Article not found');\n    } else {\n      Article.findByIdAndRemove(req.params.id)\n        .then(function() { res.status(200).json(\"Article deleted\") })\n        .catch(function(err) {\n          res.status(400).send(\"Article delete failed.\");\n        })\n    }\n  });\n})\n\nmodule.exports = router;\n```\nIn the server.js file we imported our router object and then chained it to our Express app object.  \nThe first argument '/api' applies our router object when the '/api' path is called.\n```javascript\n// server.js\nconst router = require('./routes/index');\n...\napp.use('/api', router);\n```\nRememmber the Model-View-Controller pattern (MVC)? Express uses that pattern as well.  \n- Model we talked about. \n- Controller is a combination between the actions directly with the routes rather than separating them into separate route and controller files. \n- view will be our React front end. Or you may say our view is the JSON responses returned when accessed by our front end React app. Let's see those in action.  \nWith all the changes it's best to just restart your server:\n```javascript\n$ CTRL+C\n$ nodemon\n```\nThen in your browser go to the API articles endpoint:\nhttp://localhost:3001/api/articles\nAnd you should see an empty array. Congratulations!  \nAll that hard work paid off, An empty array. Now lets test all the endpoints using Postman.\n___\n**Postman**\nHere are the CRUD actions hitting our API's endpoints:\n- Get Articles request: GET *`http://localhost:3001/api/articles`*\n- Get Article request: GET *`http://localhost:3001/api/articles/article._id`*\n- Add Article request: POST *`http://localhost:3001/api/articles`*\nHeaders: Content-Type application/json\nBody: {\"title\": \"Learn Web Development\", \"content\": \"Lorem ipsum.\"}\n- Update Article request: PATCH *`http://localhost:3001/api/articles/article._id`*\nHeaders: Content-Type application/json\nBody: {\"title\": \"Learn APIs\", \"content\": \"Blah Blah Blah.\"}\n- Delete Article request: DELETE *`http://localhost:3001/api/articles/article_id`*\n___\nIf everything works then our simple API is done! We can use this API as the back end for a mobile app, or to be accessed by other websites to display our amazing articles.  \nWe will integrate it with React as the front end framework.\n\n***You did alot, maybe take a coffee break and come back?***\n\n**Frontend Setup**\n*Create-react-app*\nWe already created an API that we will be using as our back end.  \nWe could keep the front end and back end code in completely separate locations, but if we are to deploy our application in production as an integrated web application it's easier to keep them together.  \nWe'll add a directory called client to our project and place our React application there.\n```javascript\ncreate-react-app client\ncd client\n```\nPoof... we now have a working React app ready to go. Start the server:\nnpm start\nAnd this should open your browser to localhost:3000 and greet you with a Welcome to React web page including a spinning logo. We're in business.\n___\n**Third party packages**\nWe will be using two third party packages, React Router for routing and Axios for AJAX requests.  \n___\n**client/package.json**\nInside our React file structure is package.json, this file lists the locally installed packages as dependencies.  \nYou should see react, react-dom, and react-scripts in there. You can read about it at docs.[npmjs.com - package.json](https://docs.npmjs.com/getting-started/using-a-package.json).\n\nInstall the react-router-dom (for routing), axios (for AJAX requests), and bootstrap packages. The bootstrap package is a popular CSS library that we'll use for convenience and discuss a bit more in the stylesheets section.\n```javascript\nnpm install react-router-dom axios bootstrap\n```\nNow if you look back at the packages.json file you should see those packages as dependencies.  \nMake one more change to the package.json file.  \n- Add a proxy property set to your API's port.  \nThis will automatically be added to the API routes we call from our React front end, so we only have to use the paths, not the full URLs in our code. There are other ways we could accomplish the same thing, but this makes it easier if you deploy your app to a platform like Heroku. And we won't need to use the cors package in our API.\n```javascript\n// client/package.json\n{\n  \"name\": \"client\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"proxy\": \"http://localhost:3001\",\n  \"dependencies\": {\n    \"axios\": \"^0.19.0\",\n    \"bootstrap\": \"^4.3.1\",\n    \"react\": \"^16.8.6\",\n    \"react-dom\": \"^16.8.6\",\n    \"react-router-dom\": \"^5.0.1\",\n    \"react-scripts\": \"3.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n  ...\n}\n```\n**File Structure**\nIf you look at the files and directories generated in the client directory, besides a folder for the node_modules you'll see a \"public\" and a \"src\" directory.  \nThese are where you add your own files, right now there are no sub-directories in those folders so things can get pretty cluttered quickly if we don't add some structure.  \nFrom the client directory you can use these UNIX commands to add and remove the relevant directories and files. Or do it from your text editor if you prefer.\n```javascript\nrm README.md\nrm -rf .git\nmkdir -p src/components/pages\ntouch src/components/pages/Home.js\nmkdir src/components/articles\ntouch src/components/articles/ArticleList.js\ntouch src/components/articles/ArticleInfo.js\ntouch src/components/articles/ArticleAdd.js\ntouch src/components/articles/ArticleEdit.js\n```\nWe removed some unnecessary files including the git repository that create-react-app generated for us (\"**rm** does this\"). We won't be using git in this project but if we were we would generate a git repository in the project root directory for our API and our React client combined.  \nYou can leave the .gitignore file though since git allows multiple gitignore files.\nWe left the logo.svg file for now so our app doesn't crash. You can delete it at the end.\n___\n**Stylesheets**\nThe index.css file is for our app-wide css. If you want to add custom CSS classes that apply to the whole app this is where you would do it.  \nThe App.css file is specific to the App.component we are going to fill out.  \nDelete the CSS that's in there now so it doesn't conflict with our app.\n```css\n// src/stylesheets/App.css\n/* Remove all the CSS classes */\n```\nTo add css classes that apply only to a particular component you could create a css file in the same folder as that component and import it in the component(s) that use it.  \n**Bootstrap**: For convenience we're using Bootstrap for our styling. We installed the bootstrap package earlier. Now import it to our index.js file.\n```javascript\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport './index.css';\nimport App from './App';\n...\n```\nIf you want to use the JavaScript features of Bootstrap like drop-down menus you can also install the react-bootstrap package,  \nWe won't use those in this project.\n___\n**public/index.html - Our Single Page App**\nThis is a Single-Page Application (SPA) with CRUD capabilities, it is indeed single page.  \nWe only have one html file sitting in the public folder: \n- public/index.html.  \nIt has your standard HTML page structure with one element inside the body. An empty div tag with id name of root <div id=\"root\"></div>.  \nThat is where React renders it's output with JavaScript. There's nothing special about the name \"root.\" It can be any name.\n___\n**src/index.js File**\nIn the src/index.js file we import the React library and render our main component. Other than adding the Bootstrap import above, we don't need to make any changes to the src/index.js file. It should look like this.\n```javascript\n// src/index.js\nimport React from 'react';                                   #1a\nimport ReactDOM from 'react-dom';                            #1b\nimport 'bootstrap/dist/css/bootstrap.css';          \nimport './index.css';\nimport App from './App';                                     #1c\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));   #2\nserviceWorker.unregister();                                  #3\n```\n- #1 We import the React and ReactDOM libraries, and the App.jsx file (containing the App component).\n- #2 The ReactDOM module's render method is what renders your React components to the public/index.html page. It takes two arguments. The first calls our component which is a custom React element called \"App\", or whatever name you want to give it. The second argument is the target element where we will render the output from <App />. In this case the element with the id of \"root\".\n- #3 The service worker is a web API that helps you cache your assets and other files so that when the user is offline or on a slow network they can still see results on the screen. It is actually not activated by default so we're leaving it that way as well (change .unregister to .register to make it active).\n___\n**React Components**\n*This is a sole reminder*\n- With React you split your user interface into components, each component returns some JSX which ultimately gets rendered as HTML to the user interface.  \nIn our case we are creating the front end to a CRUD application.  \nWe need components to correspond with the API's endpoints to perform the CRUD actions.\n- A few notes on syntax. We can use all the latest JavaScript syntax without worrying about browser compatibility because create-react-app installed Babel which compiles our JavaScript into ES5.  \nWe did not add the step of installing Babel in our API, so while we could still use most of the ES6 syntax, there are some features not yet supported by Node like the Import and Export syntax. But we can and will be using those here.  \nAlso, in general I am using the declaration syntax for functions rather than arrow functions just to make it explicit when you are returning a value.  \nBut it is recommended to use arrow functions if you prefer it.\n- The App.js component file holds the structure for our web page:\n  - The ArticleList\n  - ArticleInfo\n  - ArticleAdd\n  - ArticleEdit \nThese components represent views that correspond to the Read, Read and Delete, Create, and Update actions respectively.  \nWe'll also add a Home component to be our home page.  \n*Note that component names must be capitalized.*  \nIn each file we will build one React component, with the exception of App.js where we build three.  \nWe could break it out even further, like a form component that gets imported to the ArticleAdd and ArticleEdit components, but we won't.\n___\n**Home Component**\nBefore we build our full CRUD app let's start out with a very simple component called Home. We already created an empty Home.js file. Populate it with the below:\n```javascript\n// src/components/pages/home.jsx\nimport React from 'react'; \n\nfunction Home() { \n  return (\n    <div className=\"jumbotron\">\n      <h1>Home Page</h1>\n    </div>\n  );\n}\n\nexport default Home; \n```\n- We are \n  - importing React\n  - creating a component\n  - then exporting it\n- Home simply returns some JSX. JSX looks like HTML but it actually isn't, not yet anyway.  \nYou'll notice subtle differences between JSX and HTML like you have to use the className attribute instead of class since \"class\" is a reserved word in JavaScript.  \nBut React ultimately converts JSX to HTML through its ReactDOM.render method. \n\n*Right now this file is just sitting in space not connected to anything*\n___\n**App component**\nThe term Single-Page App can be a little misleading. While it is indeed a single html page, that doesn't mean you can't have multiple views with changes to the URL.  \nWe will use the React Router package that we installed to do just that.  \nWe will also perform the standard CRUD actions in our single page interacting with the API to:\n- get articles\n- post new articles\n- edit existing articles\n- delete articles\nInstead of doing those things all on separate HTML pages as you would in an traditional web app, we will do it from our single page using AJAX calls with the help of the Axios package we installed.  \nReact will move the data around using JavaScript which can add significant speed over entire page loads from the server.  \nThe top level component for our app is the App component. That is what is returning the Welcome to React page we see in the browser.  \nReplace that with a Navigation bar and a place to render the other components. Here is the code for the App.js file all at once:\n```javascript\n// src/App.js\n\nimport React from 'react';\nimport {BrowserRouter as Router, Route, NavLink, Switch} from 'react-router-dom';\nimport './App.css';\nimport Home from './components/pages/Home';\nimport ArticleList from './components/articles/ArticleList';\nimport ArticleInfo from './components/articles/ArticleInfo';\nimport ArticleAdd from './components/articles/ArticleAdd';\nimport ArticleEdit from './components/articles/ArticleEdit';\n\nfunction App() {\n  return (\n    <div className=\"App\">     \n      <Router>\n        <Navigation />\n        <div className=\"container\">\n          <Main />\n        </div>\n      </Router>\n    </div>\n  );\n}\n\nfunction Navigation() {\n  return(\n    <nav className=\"navbar navbar-expand-lg navbar-dark bg-dark mb-4\">\n      <div className='container'>\n        <ul className=\"navbar-nav mr-auto\">\n          <li className=\"nav-item\"><NavLink exact className=\"nav-link\" activeClassName=\"active\" to=\"/\">Home</NavLink></li>\n          <li className=\"nav-item\"><NavLink exact className=\"nav-link\" activeClassName=\"active\" to=\"/articles\">Articles</NavLink></li>\n        </ul>\n      </div>\n    </nav>\n  );\n}\n\nfunction Main() {\n  return(\n    <Switch>\n      <Route exact path=\"/\" component={Home} />\n      <Route exact path=\"/articles\" component={ArticleList} />\n      <Route exact path=\"/articles/new\" component={ArticleAdd} />\n      <Route exact path=\"/articles/:_id\" component={ArticleInfo} />\n      <Route exact path=\"/articles/:_id/edit\" component={ArticleEdit} />\n    </Switch>\n  );\n}\n\nexport default App;\n```\nFirst thing's first. Once you add the code and save the file, go to the browser and make sure you didn't get any errors.  \nWe removed the Welcome to React header and logo and replaced it with a navigation bar with two links, and a simple home page jumbotron.  \nIf you do get an error try restarting the server: \n```javascript\n$ CTRL+C \n$ npm start\n```\nIf you click on the articles link it will give you an error because we haven't populated that yet.\n\nThis file actually contains three separate functional components\n- App\n- Navigation\n- Main\nBut most of this code relates to Navigation and the React Router package. React Router is the most popular Routing package.  \nThe docs are at [reacttraining.com/react-router/web/guides](https://reacttraining.com/react-router/web/guides/philosophy) which looks like a third party training site, and it is.  \nBut they are the ones who created the React Router package (not Facebook's React team).  \nAlright, let's break this down.\n\n*At the top are all of our imports:*\n```javascript\nimport React from 'react';                                                        #1\nimport {BrowserRouter as Router, Route, NavLink, Switch} from 'react-router-dom'; #2\nimport \"bootstrap/dist/css/bootstrap.min.css\";                                    #3\nimport '../stylesheets/App.css';              \nimport Home from './components/pages/Home';                                       #4\nimport ArticleList from './components/articles/ArticleList';\nimport ArticleInfo from './components/articles/ArticleInfo';\nimport ArticleAdd from './components/articles/ArticleAdd';\nimport ArticleEdit from './components/articles/ArticleEdit';\n```\n1) To create a component we need to import the React library.\n2) Import the components you need from the react-router-dom module. React Router also has a react-router-native module for mobile apps. In this case we'll import the BrowserRouter (giving it an alias of Router), Route, NavLink, and Switch components.\n3) Import the Bootstrap CSS library we added.\n4) Import the other components that we will be calling with our Routes. Each of those files will contain a functional component.\n\n**The App component's return statement:**\n```javascript\nfunction App() {\n  return (\n    <div className=\"App\">  \n      <Router>                            #1\n        <Navigation />                    #2\n        <div className=\"container\">          \n          <Main />                        #3\n        </div>\n      </Router>\n    </div>\n  );\n}\n```\n1) In the App function's return statement we appended the <Router> element to manage our routing. It contains two custom elements:\n2 & 3) ***<Navigation />*** and ***<Main />*** are custom elements that call the corresponding components.  \nNothing special about those names, you could call them what you like. Those components return JSX that gets inserted into the App component.\n\n**The Navigation component:**\n```javascript\nfunction Navigation() {                                       #1\n  return(\n    <nav className=\"navbar navbar-expand-lg navbar-dark bg-dark mb-4\">\n      <div className='container'>\n        <ul className=\"navbar-nav mr-auto\">\n          <li className=\"nav-item\">                             #2\n            <NavLink exact className=\"nav-link\" activeClassName=\"active\" to=\"/\">Home</NavLink>\n          </li>                                                 #3\n          <li className=\"nav-item\">\n            <NavLink exact className=\"nav-link\" activeClassName=\"active\" to=\"/articles\">Articles</NavLink>\n          </li>\n        </ul>\n      <div>\n    </nav>\n  );\n}\n```\n1) The Navigation component returns JSX that ultimately renders the nav bar using the Bootstrap classes we provide here.\n2 & 3) The React Router NavLink component is a subset of a Link component that we'll use shortly.  \nIt provides the activeClassName property to style the link differently when it's active.  \nThe other thing to note is the \"exact\" attribute, which is the shorthand for \"exact=true.\"  \nThat means the route has to be the exact route provided with the \"to\" attribute. The default is that it just contains the route provided, so the \"/\" route by default would include any route that contains \"/\", which is all routes.  \nSo we need the *exact* attribute here.\n\n**The Main component:**\n```javascript\nfunction Main() {                                                      #1\n  return(\n    <Switch>                                                           #2\n      <Route exact path=\"/\" component={Home} />                        #3\n      <Route exact path=\"/articles\" component={ArticleList} />\n      <Route exact path=\"/articles/new\" component={ArticleAdd} />\n      <Route exact path=\"/articles/:_id\" component={ArticleInfo} />\n      <Route exact path=\"/articles/:_id/edit\" component={ArticleEdit} />\n    </Switch>\n  )\n);\n```\n1) The *Main* component is where we insert all our Route elements.\n2) The React Router switch statement works like a JavaScript switch statement. It checks each statement below it in order until there is a match.\n3) Route is a React Router element that takes as attributes the path and the component to call if there is a match. The \"exact\" attribute requires the match be exact.\n\n*Note that throughout this project I will be using the function declaration syntax rather than function expressions or arrow functions, unless there is a specific reason those should be used. But if you prefer arrow function syntax feel free to change it.*\n___\n**ArticleList component**\nNow it's time to do our first API call! We'll go to the server to retrieve a list of all the articles in the database.  \nIn our file structure setup we created the ArticleList.js file.  \nPopulate it with the ArticleList component below and save it.\n```javascript\n// src/component/articles/Articlelist.jsx\n\nimport React, { useState, useEffect } from 'react';\nimport  axios  from 'axios';\nimport { Link } from 'react-router-dom';\n\nfunction ArticleList() {\n  const [articles, setArticles] = useState([])\n\n  useEffect(function() {\n    async function getArticles() {\n      try {\n        const response = await axios.get(\"/api/articles\");\n        setArticles(response.data);\n      } catch(error) {\n        console.log('error', error);\n      }\n    }        \n    getArticles();\n  }, []);\n\n  return (\n    <div>\n      <h2>\n        Articles\n        <Link to=\"/articles/new\" className=\"btn btn-primary float-right\">Create Article</Link> \n      </h2>\n      <hr/>\n      {articles.map((article) => {\n        return(\n          <div key={article._id}>\n            <h4><Link to={`/articles/${article._id}`}>{article.title}</Link></h4>\n            <small>_id: {article._id}</small>\n            <hr/>\n          </div>\n        )     \n      })}\n    </div>\n  )\n}\n\nexport default ArticleList;\n```\nLet's see if it works. If you have a local MongoDB database make sure that is running, or start it in a separate terminal window (any directory will work):\n```javascript\nmongod\n```\nTo start the API server in a separate terminal window go to the project's root directory:\n```javascript\nnodemon\n```\nNow if you go to the browser and click on the Articles link you should see a list of articles from the database. This corresponds with the JSON view at `http://localhost:3001/api/articles` which you can view in a separate browser tab.  \nThe connection to the API is working! Also, notice that we are running two separate servers on two different ports:\n- For the back-end API app\n- For the React front-end app.\n\nTime to break it down starting with...\n\n**The imports:**\n```javascript\nimport React, { useState, useEffect } from 'react';  #1\nimport { get } from 'axios';                         #2\nimport { Link } from 'react-router-dom';             #3\n```\n1) React components require the React library. Additionally, import useState and useEffect to use the State and Effect hooks. Read Hooks at a Glance for a quick summary. 2) To access data from the API we'll make an AJAX get request using the Axios package we added earlier.\n3) We will include links to the the individual Article pages and to the New Article form, so import the Link component from the react-router-dom module.\n\n**Declare the ArticleList functional component:**\n```javascript\nfunction ArticleList() {\n```\nUseState Hook:\n```javascript\n  const [articles, setArticles] = useState([]) \n```\nSet the initial state of our component to an empty array with the useState hook. UseState is a two element array that contains the current state as the first element and a function to update it as the second.  \nHere we're assigning the (const) variable \"articles\" to the current state value, and \"setArticles\" to the update function.\n\n**UseEffect Hook:**\n```javascript\n  useEffect(function() {                                #1          \n    async function getArticles() {                      #2\n      try {\n        const response = await get(\"/api/articles\");    #3\n        setArticles(response.data);                     #4\n      } catch(error) {\n        console.log('error', error);\n      }\n    }        \n    getArticles();\n  }, []);                                               #5\n```                                       \n1) Place your asynchronous code here such as your API call. Code in the useEffect method runs after the initial render of the component and changes the state of the component.\n2) The API call is asynchronous since it sends a get request to the API and waits for a response from the server.\n3) We're using the Axios library to make an AJAX get request and convert the JSON response to a JavaScript object. We aren't including the domain part of the URL -- `http://localhost:3001` *-- because we added it as a proxy in the package.json file.*\n4) Call the *setArticles* method to change the articles state, passing in the response object we got back from the API (which is an array of article objects). The React useState hook will change the articles state to this object.\n5) The useEffect hook takes a second argument that instructs React to rerun the effect. We only want to run the effect once to get the list of articles so just set it to an empty array.\n\n**Return statement:**\n```javascript\n  return (                                          #1\n    <div>\n      {articles.map((article) => {                  #2\n        return(\n          <div key={article._id}>                   #3\n            <h2><Link to={`/articles/${article._id}`}>{article.title}</Link></h2>         #4\n            <small>{article._id}</small>\n            <hr/>\n          </div>\n        )     \n      })}\n      <Link to=\"/articles/new\" className=\"btn btn-outline-primary\">Create Article</Link>  #5\n    </div>\n  )\n```\n1) React components return JSX which is converted to HTML.  \n2) Access the articles state object which is an array of the article objects we got from the API. The JavaScript map method iterates though the array transforming each item based on the function provided and returning a new transformed array.\n3) React requires that we assign a unique key to each item when iterating though a list, so we are assigning the article id attribute.\n4) Here we transform the article objects into JSX that puts the article title into a link, displays the article id, and adds a horizontal line at the bottom.\n5) At the end we include a link to the new articles route.\n___\n**Chrome Developer Tools**\nIf you want to get a better understanding of state then make use of logging. Add \n```javascript\nconsole.log(n, articles);\n``` \nstatements to your component with n being sequential numbers. \n- Refresh your browser\n- open Chrome Developer Tools - Inspect and go to the Console tab.  \nThere you can see the console logs of the data pulled and the order the code is executed.\n___\n**ArticleInfo component**\nOn to the ArticleInfo component which corresponds to our API's Get /api/articles endpoint.  \nPopulate the file with the below and save it.\n```javascript\n// src/components/articles/ArticleInfo.js\n\nimport React, { useState, useEffect } from \"react\";\nimport axios from 'axios';                               #1\nimport { Link } from 'react-router-dom';\n\nfunction ArticleInfo(props) {\n  const [article, setArticle] = useState({});            #2\n\n  useEffect(function() {                                 #3a\n    async function getArticle() {\n      try {\n        const response = await axios.get(`/api/articles/${props.match.params._id}`); #3b\n        setArticle(response.data);                       #3c\n      } catch(error) {\n        console.log('error', error);\n      }\n    }\n    getArticle();    \n  }, [props]);                                           #3d\n\n  async function handleDelete() {                        #4a\n    try {\n      await axios.delete(`/api/articles/${props.match.params._id}`); #4b\n      props.history.push(\"/articles\");                   #4c\n    } catch(error) {\n      console.error(error);\n    }\n  }\n\n  return (                                               #5\n    <div>\n      <h2>{article.title}</h2>\n      <small>_id: {article._id}</small>\n      <p>{article.content}</p>\n      <div className=\"btn-group\">\n        <Link to={`/articles/${article._id}/edit`} className=\"btn btn-primary\">Edit</Link> \n        <button onClick={handleDelete} className=\"btn btn-danger\">Delete</button> \n        <Link to=\"/articles\" className=\"btn btn-secondary\">Close</Link>\n      </div>\n      <hr/>\n    </div>\n  );\n};\n\nexport default ArticleInfo;\n```\nNow test it out in the browser. From the Articles page, if you click on an article title it should take you to the article page.  \nClick the cancel button and it should take you back to the Article List page.  \nSelect another article and this time click delete.  \nPoof, it's gone if everything is working correctly, which means you have both read and write access to the API. You should be back to the articles list page minus one article.\n\nLet's break down the code.\n1) The imports are the same as for ArticleList. The only thing to note is we are importing the whole Axios library rather than just the specific methods we are using (get and delete). That's because \"delete\" is a JavaScript reserved word. Since we're importing the whole Axios library, we call the specific methods with axios.get and axios.delete.\n2) Call the useState hook and set the value to a variable called article with an initial state of an empty object {}. Assign the update function to the variable name setArticle. \n3a) The useEffect hook is similar to ArticleList.\n3b) But this time we when we make our GET request to the API we need to send the article id. So now the props object comes into play. If you look in the Chrome Developer Tools \"React\" tab and search on ArticleList you'll see the props and state objects in the pane to the right. Props contains three objects, one of which is called Match. Match contains the path (articles/:_id), the url (articles/id), and another object called params. Params contains a single path param of :_id. So to get the article id we need to chain this all together with this.props.match.params._id.\n3c) When the response to the AJAX request comes back we will use the setArticle method to assign response data from the API to the article object in the component's state.\n3d) Adding props to the second argument of the useEffect hook instructs React to re-run the effect if props changes.\n\nIf you prefer to use the promise.then syntax rather than async/await, then the useEffect hook would look something like this:\n```javascript\n  useEffect(function() {\n    axios.get(`/api/articles/${props.match.params._id}`)\n      .then(function(response) {\n        setArticle(response.data);\n      })\n      .catch(function (error) {\n        console.log('error', error);\n      });\n  }, [props]);\n  ```\n4a) When the user clicks the \"Delete\" button, the onClick event calls the handleDelete handler function.\n4b) We use the Axios library to send a delete request to the provided URL.\n4c) When we get a response from the delete request we will redirect to the articles page using props.history.push(\"/articles\").  \nWe saw earlier in Chrome Dev Tools that the props contained three objects: history, location, and match.  \nThe history object contains a stack of the URL locations visited with the most recent on top, including the current path at the very top.  \n\"Push\" is a JavaScript method that adds an item to the end of an array, so pushing the articles route to the end (top) of the history stack will make that route the current location.\n\nThe promises.then syntax for the handleDelete function would look something like this:\n```javascript\n  function handleDelete() {\n    axios.delete(`/api/articles/${props.match.params._id}`)\n      .then(function() { props.history.push(\"/articles\") })\n      .catch(function(error) { console.log('error', error); });\n  }\n```\n5) The component returns the JSX which is converted to HTML. It includes the article data and buttons for edit, delete and back.\n___\n**ArticleAdd component**\nWe've covered Read and Delete, how about Create? Populate the *ArticleAdd.jsx* file with the below.\n```javascript\n//src/components/articles/ArticleAdd.js\n\nimport React, { useState } from \"react\";                #1a\nimport { post } from 'axios';                           #1b\n\nfunction ArticleAdd(props) {\n  const initialState = { title: '', content: '' }\n  const [article, setArticle] = useState(initialState)  #2\n\n  function handleChange(event) {                        #3\n    setArticle({...article, [event.target.name]: event.target.value})\n  }\n\n  function handleSubmit(event) {                        #4a\n    event.preventDefault();                             #4b\n    if(!article.title || !article.content ) return      #4c\n    async function postArticle() {\n      try {\n        const response = await post('/api/articles', article); #4d\n        props.history.push(`/articles/${response.data._id}`);  #4e\n      } catch(error) {\n        console.log('error', error);\n      }\n    }\n    postArticle();\n  }\n\n  function handleCancel() {\n    props.history.push(\"/articles\");\n  }\n\n  return (                                              #5\n    <div>\n      <h1>Create Article</h1>\n      <hr/>\n      <form onSubmit={handleSubmit}>\n        <div className=\"form-group\">\n          <label>Title</label>\n          <input name=\"title\" type=\"text\" value={article.title} onChange={handleChange} className=\"form-control\" />\n        </div>\n        <div className=\"form-group\">\n          <label>Content</label>\n          <textarea name=\"content\" rows=\"5\" value={article.content} onChange={handleChange} className=\"form-control\" />\n        </div>\n        <div className=\"btn-group\">\n          <input type=\"submit\" value=\"Submit\" className=\"btn btn-primary\" />\n          <button type=\"button\" onClick={handleCancel} className=\"btn btn-secondary\">Cancel</button>\n        </div>\n      </form>\n    </div>\n  );\n}\n\nexport default ArticleAdd;\n```\nTest it out to make sure it works. From the Articles List page click on the Create Article button, there should be a form.  \n- First hit the cancel button to make sure you go back to the Articles list page. \n- Click Create Article again and this time write an article. \n- Write about anything you want. \n- Then click create and you should be taken to your new article info page. \nNice! But, how did we get here?\n\n- 1) In our React imports we will only be using the useState hook. For our Axios imports we'll be using a post request.\n- 2) Our *useState* hook will create a state named article with initial state set to an object with title and content properties set to empty strings. We'll also set the function for updating state to variable \"setArticle\".\n- 3) Every time a user types a character in a form input field the onChange property calls the handleChange handler function passing the event object as an implicit argument.  \nThe event object includes the target (i.e., the form field element) which has attributes for field name and value.  \nThe handleChange function in turn calls setArticle which updates the article state with the new value. You need to include the ...article spread operator so that the new character is added to the existing article value, otherwise it will just overwrite it. You can see the process in action by adding\n```javascript\nconsole.log(event.target); \n```\nto the *handleChange* function then look at the console after typing in a character.  \nYou can also look at the React tab in the console after drilling down to the *ArticleAdd* component and you will see State update after every key is pressed.\n- 4a) When the user clicks the form's submit button, it triggers the onClick event which calls the handleSubmit handler function.\n- 4b) Normally when an HTML form is submitted a new page is called. Since we are sending the data via AJAX and don't want to be sent to a new page we need add preventDefault().\n- 4c) We add a conditional that checks if either of the form fields are empty. If they are we stop the function by returning nothing. 4d) We'll sent a POST request to the API endpoint sending the current state.\n- 4e) Then using ES6 promises, when the new article is returned we'll use the response.data object to get the id so we can redirect to the correct ArticleInfo route.\nIf you prefer to use the promises.then syntax it would look something like this:\n```javascript\n    axios.post('/api/articles', article)\n      .then(function(response) {\n        props.history.push(`/articles/${response.data._id}`);\n      })\n      .catch(function(error) { console.log('error', error) });    \n```\n- 5) Our return statement is the JSX for our form. Each form field element has properties for name, value (set to the article state) and onClick set to a handler function. The form element has an onSubmit property set to a handler function that is triggered when the user clicks the submit button.\n___\n**ArticleEdit component**\nOnly one more component to go. Here's the code.\n```javascript\n// src/components/articles/ArticleEdit.js\n\nimport React, { useState, useEffect } from \"react\";\nimport { get, patch } from 'axios';\n\nfunction ArticleEdit(props) {\n\n  const initialState = { title: '', content: '' }\n  const [article, setArticle] = useState(initialState)\n\n  useEffect(function() {\n    async function getArticle() {\n      try {\n        const response = await get(`/api/articles/${props.match.params._id}`);\n        setArticle(response.data);        \n      } catch(error) {\n        console.log(error);\n      }\n    }\n    getArticle();    \n  }, [props]);\n\n  function handleSubmit(event) {\n    event.preventDefault();\n    async function updateArticle() {\n      try {\n        await patch(`/api/articles/${article._id}`, article);\n        props.history.push(`/articles/${article._id}`);        \n      } catch(error) {\n        console.log(error);\n      }\n    }\n    updateArticle();\n  }\n\n  function handleChange(event) {\n    setArticle({...article, [event.target.name]: event.target.value})\n  }\n\n  function handleCancel() {\n    props.history.push(`/articles/${article._id}`);\n  }\n\n  return (\n    <div>\n      <h1>Edit {article.title}</h1>\n      <hr/>\n      <form onSubmit={handleSubmit}>\n        <div className=\"form-group\">\n          <label>Title</label>\n          <input type=\"text\" name=\"title\" value={article.title} onChange={handleChange} className=\"form-control\" />\n        </div>\n        <div className=\"form-group\">\n          <label>Content</label>\n          <textarea name=\"content\" rows=\"5\" value={article.content} onChange={handleChange} className=\"form-control\" />\n        </div>\n        <div className=\"btn-group\">\n          <button type=\"submit\" className=\"btn btn-primary\">Update</button>\n          <button type=\"button\" onClick={handleCancel} className=\"btn btn-secondary\">Cancel</button>\n        </div>\n      </form>\n    </div>\n  );\n}\n\nexport default ArticleEdit;\n```\nSave it, then edit an article to make sure it works.\n\nThis component is essentially a combination of the ArticleInfo and ArticleAdd components. So it would be a good exercise for you to go through the lines of code and make sure you understand what they are doing.\n**This completes the React portion of this app!**\n___\n**Run the API and React Client with one command**\nRight now we need separate terminal windows open to run our back end API server (port 3001) and our front end React app (port 3000), Not to mention our MongoDB server.  \nFor convenience we can run our API and React apps with one command using the Concurrently package.  \nMake sure you are in the project's root directory (not in the client folder).  \nUsing the --dev flag installs it as a development environment dependency.\n```javascript\nnpm install concurrently --save-dev\n```\nOpen the *package.json* file in the project's root directory (not the one in the client folder) and add the highlighted script below.  \n*Note that you need to add a comma after the start script.*\n```javascript\n//package.json\n  ...\n  \"scripts\": {\n    \"start\": \"node server.js\",\n    \"dev\": \"concurrently \\\"nodemon server.js\\\" \\\"cd client && npm run start\\\"\"\n  },\n  ...\n  \"devDependencies\": {\n    \"concurrently\": \"^4.1.1\"\n  },\n```\nThis will run the nodemon command on the API application starting the server on port 3001. \n Then it will cd to the client directory and run the start command which will run the React app on port 3000.  \n To execute this script, make sure you stop both servers first, then from the project's root directory run:\n```javascript\nnpm run dev\n```\nThis should start both servers and open the React app in your browser.\n___\n**Deployment**\n*Dotenv Package and environmental variables*\nHeroku requires you to use a cloud database platform for MongoDB. MongoDB's Atlas cloud service requires a user name and password as part of the URL.  \nTo keep these private you should use environmental variables so that they are not explicitly in your application's code.  \nAssuming you are using Atlas for both development and production, you should add the dotenv package for your development environment if you expect to expose the file in a place like a public github repository.  \nFrom the project's root directory:\n```javascript\nnpm install dotenv\n```\nIn Node, environment variables can be accessed on the process.env object. The dotenv middleware looks for a file called .env and loads it's contents into the process.env variable for use in your code.\nCreate a *.env* file in the project's root directory:\n```javascript\ntouch .env\n```\nAdd environmental variables on new lines in the form of NAME=VALUE.  \nBy convention, use names in all upper case with words separated by underscores like MONGODB_URI.  \nAdd your MongoDB Atlas database link since it contains your user name and password. Something like this:\n```javascript\n// .env\n\nMONGODB_URI=mongodb+srv://user:password@cluster-number.mongodb.net/test?retryWrites=true&w=majority\n```\nWe are only using the .env file in our development environment. When you deploy your app on Heroku you need to add this as an environmental variable on Heroku at that time.\n___\n**Server.js Update**\nUpdate the server.js file with changes related to Heroku highlighted and explained below.\n```javascript\n// server.js\n\nconst express = require('express');\nconst mongoose = require('mongoose');\nconst router = require('./routes/index');\n+ const path = require('path');               #1  \n+ const PORT = process.env.PORT || 3001;      #2\n+ require('dotenv').config();                 #3\n\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\napp.use(express.json());\napp.use('/api', router);\n\n+ mongoose.connect(process.env.MONGODB_URI, { useNewUrlParser: true }); #4\nmongoose.connection.once('open', () => {\n  console.log('Connected to the Database.');\n});\nmongoose.connection.on('error', err => {\n  console.log('Mongoose Connection Error : ' + err);\n});\n\n+ if (process.env.NODE_ENV === 'production') {      #5     \n+   app.use(express.static('client/build'));\n+\n+   app.get('*', (req, res) => {\n+     res.sendFile(path.resolve(__dirname, 'client', 'build', 'index.html'));\n+   });\n+ }\n\napp.listen(PORT, () => {\n  console.log(`Server listening on port ${PORT}.`);\n});\n```\n- 1) Path is a module within Node so we don't install it with npm. The path module provides utilities for working with file and directory paths and is needed to work on Heroku.\n- 2) Heroku will assign a port via the PORT environmental variable. We'll use the or operator || to assign that as the port or 3001 if it is null (i.e., if we are in the dev environment).\n- 3) Require and configure dotenv middleware.\n- 4) Connect to the database URI taken from the environmental variable.\nYou could use a local MongoDB instance for your development environment and use the cloud for production.  \nIf you take that route then you would would set it up like this:\n```javascript\nconst LOCAL_DB = \"mongodb://127.0.0.1:27017/my_local_db\";\nmongoose.connect(process.env.MONGODB_URI || LOCAL_DB, { useNewUrlParser: true });\n```\n- 5) When you deploy your app to Heroku, Heroku will run the build command on the React app and move the finished version to the build folder.  \nThis conditional statement tells Heroku that your React files will be in the client/build folder and URL requests will go to the *client/build/index.html* file where your SPA React app is served from.\n___\n**Package.json**\nThe React app in development is not optimized. We need to run the npm build command for React to minify all your React code and put it into a folder called build.  \nBut actually we'll instruct Heroku to do that for you when you deploy.  \nAdd a script to the package.json file in the project root directory with property heroku-postbuild (Has a \"+\" before).  \nHeroku will run that script after it builds your app.  \nThe script :\n- cds into the client directory\n- runs npm install to install the React packages\n- and npm run build to build the optimized version in the build folder. \nYour finished package.json file should look something like the below.\n```javascript\n//package.json\n\n{\n  \"name\": \"mern-blog\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Web app built with Node.js, Express, MongoDB, and React\",\n  \"main\": \"server.js\",\n  \"dependencies\": {\n    \"dotenv\": \"^8.0.0\",\n    \"express\": \"^4.17.1\",\n    \"mongoose\": \"^5.6.3\"\n  },\n  \"devDependencies\": {\n    \"concurrently\": \"^4.1.1\"\n  },\n  \"scripts\": {\n  +  \"start\": \"node server.js\",\n    \"dev\": \"concurrently \\\"nodemon server.js\\\" \\\"cd client && npm run start\\\"\",\n  +  \"heroku-postbuild\": \"cd client && npm install && npm run build\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"MIT\"\n}\n```\nAlso note the \"start\" script. We used that in development to start the Express server with npm start.  \nBut we ignored it with our npm run dev script, using nodemon instead.  \nBut for production this script will come in handy since we want Heroku to run our server file with node once it's built.\n\nOnce Heroku is done building the app it will look for a file called *Procfile* for instructions on how to start the app.  \nSo we could create a Procfile and add one line: \n```javascript\nweb: npm run start\n```\nIf Heroku doesn't find a Procfile it will run the command npm start.  \nSo that's why we need the start script to run node server.js.\n___\nGit repository\nWe will use git to push our app to Heroku.\n\nWhen we generated our React app with create-react-app, it generated a git repository and created a gitignore file in the client folder.  \nWe want one git repository in our root directory for both our API and our React client.  \nSo if you haven't already, delete the .git repository in the client folder with the following code inside the client:\n```javascript\nrm -rf .git\n```\nThe gitignore file is fine where it is. Git will honor multiple gitignore files so we'll just add another one at the root directory.\n\nNow in our project's root directory initate a new git repository and create a .gitignore file.\n```javascript\n$ git init\n$ touch .gitignore\n```\nAdd the *.env* file and the *node_modules* folders to our new gitignore file.\n```javascript\n// .gitignore\n\nnode_modules\n.env\n```\n___\n**Set up Heroku**\nFirst create an account on their [website](https://signup.heroku.com/identity)\nThen download and install the Heroku Command Line Interface on your computer [here](https://devcenter.heroku.com/articles/heroku-cli).\n\nFrom the CLI, create a new Heroku App:\n```javascript\nheroku create appname\n```\nIf your appname is already taken you'll have to pick another one. Or leave off the appname and let Heroku generate a super awesome one for you.  \nIf you want to connect your project to a real domain name you can configure Heroku to use that [here](https://devcenter.heroku.com/articles/custom-domains).\n\nThis will automatically set heroku as your git remote repository. Run the below command to confirm.  \nIt will list the project's remote git repositories (if any) and their urls.\n```javascript\ngit remote -v\n```\nSet the MongoDB uri as an environmental variable (no quotes):\n```javascript\nheroku config:set MONGODB_URI=Your db cloud link goes here\n```\n___\n**Deploy your app**\nCreate your initial git commit:\n```javascript\n$ git add -A\n$ git commit -m \"Initial commit\"\n```\nThen push the code out to heroku:\n```javascript\ngit push heroku master\n```\nIt will take a few minutes to load up. When it's finished launch the app.  \nThe below command will open the app in your browser:\n```javascript\nheroku open\n```\nIf everything went well you have a working MERN application up and running on Heroku!\n\nI know, I know, the application doesn't look good, well, thats where you come in!\nStyle this project, This is important because its a big and impressive project, but without good styling it does not look like it.\n\n**Good luck with the styling!**"}