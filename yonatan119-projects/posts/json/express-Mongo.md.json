{"layout": "post", "title": "Node.js Express MongoDB", "published": "Apr 03, 2021", "author": "yonatan119", "tags": "node, js, javascript, express, mongodb", "timestamp": 1617456634, "location": "express-Mongo.md.json", "content": "# **Getting Started:**\n- Make sure you have Node.js installed\n- Create a new directory called \"ProductsApp\".\n- Inside the newly created directory, execute the following command in the terminal:\n```javascript\nnpm init\n```\nWe already learned what this does, but lets go back to it.\n\"npm init\" results in creating a package.json file.  \nThe package.json file is used to manage the locally installed npm packages.  \nIt also includes the meta data about the project such as name and version number.\n___\n**Installing our packages**\nLets install the packages we need for this project, you guessed it.\n- ExpressJS\n- mongoose\n- body-parser: package that can be used to handle JSON requests.  \nWe can install the above mentioned packages via typing the following command in the command line. Just make sure that you are in the project directory before executing the below command.\n```javascript\nnpm install --save express body-parser mongoose\n```\n___\n**Initializing the Server:**\nCreate a new file named **app.js** directly inside the ProductsApp directory\nOpen the newly created file named **app.js** and require all the dependencies we previously installed (ExpressJS and body-parser ) -we will talk about mongoose later-\n```javascript\n// app.js\nconst express = require('express');\nconst bodyParser = require('body-parser');\n// initialize our express app\nconst app = express();\n```\nNext step would be dedicating a port number and telling our express app to listen to that port.\n```javascript\nlet port = 1234;\napp.listen(port, () => {\n    console.log('Server is up and running on port numner ' + port);\n});\n```\nNow, we should be able to test our server using the following command in the terminal\n```javascript\nnode app.js\n```\nNow we made sure that we are having a server that is up and running. However, this server does nothing! Let\u2019s work on that and make our app more complex.\n___\n**Organizing our application:**\nWe will be working with a design pattern called MVC. Its a neat way of separating parts of our app and grouping them based on their functionality and role.\n- M stands for models, this will include all the code for our database models (which in this case will be Products).\n- V stands for the views or the layout. We will not cover the views in this tutorial as we are designing an API.\n- C stands for controllers which is the logic of how the app handles the incoming requests and outgoing responses.  \nThere will be one more thing, called Routes, Routes are our guide, they tell the client (browser/mobile app) to go to which Controller once a specific url/path is requested.\nInside the ProductsApp directory, I will create the following four subdirectories(files)\n- controllers\n- models\n- routes\n- views\n**App structure**\nNow we have a server that is ready to handle our requests and some directories that would have our code.\n**Model**\nLet\u2019s start by defining our model. Create a new file in the models directory and name it **product.model.js**\n```javascript\nconst mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\nlet ProductSchema = new Schema({\n    name: {type: String, required: true, max: 100},\n    price: {type: Number, required: true},\n});\n// Export the model\nmodule.exports = mongoose.model('Product', ProductSchema);\n```\nFirst we started with requiring mongoose (An npm package to make using mongo easier) and then we define the schema for our model.  \nLast thing is exporting the model so it can be used by other files in our project.\nM model - Check.\n___\n**Routes:**\nLet\u2019s start imagining how the urls will be like and design our routes.  \nInside the routes directory, create a **product.route.js** file. This is the file that will include the routes of the products. Some developers prefer to have all the routes in a single file (**routes.js**) for example, but when your app grows this is less useful.  \nso let\u2019s structure it the right way from the beginning.\n```javascript\nconst express = require('express');\nconst router = express.Router();\n\n// Require the controllers WHICH WE DID NOT CREATE YET!!\nconst product_controller = require('../controllers/product.controller');\n\n\n// a simple test url to check that all of our files are communicating correctly.\nrouter.get('/test', product_controller.test);\nmodule.exports = router;\n```\n___\n**Controllers:**\nNext step is to implement the controllers we referenced in the routes.\ngo to our controllers directory and create a new js file named **product.controller.js** which will be the placeholder for our controllers.\n\n```javascript\nconst Product = require('../models/product.model');\n\nexports.test = function (req, res) {\n    res.send('Greetings from the Test controller!');\n};\n```\nLast step before trying out our first route is to add the route class to the **app.js**\n```javascript\n//app.js\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst product = require('./routes/product.route'); // Imports routes for the products\nconst app = express();\napp.use('/products', product);\nlet port = 1234;\napp.listen(port, () => {\n    console.log(`Server is up and running on port number ${port}`);\n});\n```\n\nNow head to your browser and try the following link: http://localhost:1234/products/test\nto validate that our test route is working.\nNow we have our very first route working. Let\u2019s get the rest working.\n___\n**Postman:**\nWe learned about postman in the databases lesson but lets go more into it.\nPostman is a very powerful HTTP client that is used for testing, documenting and the development of APIs.  \nWe will be using Postman here to test our endpoints that we will be implementing through out the rest of this project.  \nBut first, let\u2019s get familiar with Postman using our \u2018/test\u2019 route.\n- in case you didn't install postman in the previous lesson [do it now](https://www.getpostman.com/).\n- Open the app, make sure it\u2019s a GET request and type the following url \u2018localhost:1234/products/test\u2019. Just make sure that your server is still running on the port number 1234. You should be able to see \u2018Greetings from Test controller\u2019 when going on the \u2018Preview\u2019 mode in Postman.\n\n![](https://miro.medium.com/max/1500/1*G3GtxTFaTCGB_tCrdBNwVA.png)\n\n___\n**The Database:**\nOur database will be hosted remotely on mLab.  \nmLab offers a nice free tier that we can use to test our application.  \nLet\u2019s set it up.\n- Head to mLab\u2019s website.\nhttps://mlab.com/\n\n![](https://miro.medium.com/max/1050/1*fKof5SZbsAxjt7QdUhcEPg.png)\n\n- Click on \u2018Create New\u2019 from the above image.\n\n![](https://miro.medium.com/max/1050/1*gTg6df7dkbtS4zm9_02K_w.png)\n\n- Select the Sandbox Plan Type and click on \u2018Continue\u2019.\n- Type in the database name, something like \"productsproject\".\n- Once everything is ready, just click on \u2018Submit Order\u2019\n- Next step would be creating a user to be able to access the database. Simply click on \u2018Add database user.\n- Last step would be entering the data from the database user you are creating. In this tutorial, for the username we will be using \"someuser\" and for the password we will be using \"abcd1234\".  \nNow we have a database in the cloud that is ready to be accessed.\n___\n**Connecting our app to the remote Database:**\nWe need to inform our app that it should be communicating with the database we have just created on mLab.\nRemember the \"mongoose\" package we installed before? Now is the right time to use it.\nAll we have to do is head to our **app.js** file and paste the following code in it.  \n*Just remember to update the dev_db_url variable with the connection string of your remote database on mLab. Remote database string consists of your database username and password, separated by a \u2018:\u2019 and then the URL to your database instance on mLab and then the database name.*\n```javascript\n// Set up mongoose connection\nconst mongoose = require('mongoose');\nlet dev_db_url = 'mongodb://someuser:abcd1234@ds123619.mlab.com:23619/productsproject';\nlet mongoDB = process.env.MONGODB_URI || dev_db_url;\nmongoose.connect(mongoDB);\nmongoose.Promise = global.Promise;\nlet db = mongoose.connection;\ndb.on('error', console.error.bind(console, 'MongoDB connection error:'));\n```\n___\n**Body Parser**\nLast configuration thing we need for our **app.js** is using bodyParser.  \nBody Parser is an npm package that is used to parse the incoming request bodies in a middleware.\nIn you **app.js** file, add the following couple of lines.\n```javascript\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({extended: false}));\n```\nHere is how our full **app.js** file looks like\n```javascript\n// app.js\n\nconst express = require('express');\nconst bodyParser = require('body-parser');\n\nconst product = require('./routes/product.route'); // Imports routes for the products\nconst app = express();\n\n// Set up mongoose connection\nconst mongoose = require('mongoose');\nlet dev_db_url = 'mongodb://someuser:abcd1234@ds123619.mlab.com:23619/productsproject';\nconst mongoDB = process.env.MONGODB_URI || dev_db_url;\nmongoose.connect(mongoDB);\nmongoose.Promise = global.Promise;\nconst db = mongoose.connection;\ndb.on('error', console.error.bind(console, 'MongoDB connection error:'));\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({extended: false}));\napp.use('/products', product);\n\nlet port = 1234;\n\napp.listen(port, () => {\n    console.log('Server is up and running on port numner ' + port);\n});\n```\nBy now our **app.js** file is finalized and you are aware of the usage of each and every line of code in the file.\n___\n**Implementing the endpoints**\n\n**CREATE**\n*The first task in our CRUD task is to create a new product.*   \nLet\u2019s start by defining our route first.  \nHead to routes and start designing the expected path that the browser would hit and the controller that would be responsible for handling that request.\n```javascript\n// routes/products.route.js\n...\nrouter.post('/create', product_controller.product_create);\n```\nNow let\u2019s write the product_create controller in our controller file. Head to *controllers/product.controller.js* and paste the following code.\n```javascript\n// controllers/products.js\nexports.product_create = function (req, res) {\n    let product = new Product(\n        {\n            name: req.body.name,\n            price: req.body.price\n        }\n    );\n\n    product.save(function (err) {\n        if (err) {\n            return next(err);\n        }\n        res.send('Product Created successfully')\n    })\n};\n```\nThe function simply creates a new product using the data coming from a POST request and saves it to our database.\nOur last step would be validating that we can easily create a new product.  \nLet\u2019s open Postman and send a POST request to the following url *\"localhost:1234/products/create\"* and specify the POST data:\n- name: apple\n- price: 15 \nAlso make sure that you choose x-www-form-urlencoded in the Body tab in Postman as specified in the image.\n\n![](https://miro.medium.com/max/1500/1*-5zfiZ1ACxtWwITStWGc4A.png)\n\nWe can see that the response is \u2018Product Created successfully, this means that the router and the controller are working correctly.  \nTo double check that an \u2018Apple\u2019 product was created, let\u2019s check our database so head to mLab and go to the collections in your database.  \nWe can see that a new collection was created named \u2018products\u2019 and has one document.\n___\n**Read**\nThe second task in our CRUD app is to read an existing product, let\u2019s do the route.\n```javascript\n// routes/products.route.js\n...\nrouter.get('/:id', product_controller.product_details);\nNow let\u2019s write the product_details controller in our controller file. Head to controllers/product.controller.js and paste the following code.\n// controllers/products.controller.js\nexports.product_details = function (req, res) {\n    Product.findById(req.params.id, function (err, product) {\n        if (err) return next(err);\n        res.send(product);\n    })\n};\n```\nThis function simply reads an existing product from the product id being sent in the request. \n\nNow let\u2019s head to Postman and try-out our new endpoint. Call the following url *\"localhost:1234/products/PRODUCT_ID\"*.  \n\nPRODUCT_ID is the id of the object we\u2019ve created in the previous endpoint and you should get this from your database.\nWe got a response containing all the info of that specific product, you can see that it is called \"apple\" and it\u2019s price is \"15\".\n___\n**Update**\nThe third task in our CRUD app is to update an existing product, let\u2019s create the route.\n```javascript\n// routes/products.route.js\n...\nrouter.put('/:id/update', product_controller.product_update);\n```\nNow let\u2019s write the *product_details* controller in our controller file, head to *controllers/product.**controller.js*** and paste the following code.\n```javascript\n// controllers/products.controller.js\n...\nexports.product_update = function (req, res) {\n    Product.findByIdAndUpdate(req.params.id, {$set: req.body}, function (err, product) {\n        if (err) return next(err);\n        res.send('Product udpated.');\n    });\n};\n```\nThe function simply finds an existing product using its id that was sent in the request.\n\nNow let\u2019s head to Postman and try-out our new endpoint. Call the following URL *\"localhost:1234/products/**PRODUCT_ID**/update\"*\n\nPRODUCT_ID is the id of the object we\u2019ve created in the previous endpoint and you should get this from your database.\nLets update the product name to \u2018apple2\u2019 and afterwards we can see a response saying \u2018Product updated.\u2019\nWe can also check the database to see if the database document was updated successfully or not.  \n___\n**Delete**\nThe last task in our CRUD app is to delete an existing product. Let\u2019s do the route.\n```javascript\n// routes/products.route.js\n...\nrouter.delete('/:id/delete', product_controller.product_delete);\n```\nNow let\u2019s write the product_delete controller in our controller file. Head to *controllers/**products.js*** and paste the following code.\n```javascript\n// controllers/products.controller.js\nexports.product_delete = function (req, res) {\n    Product.findByIdAndRemove(req.params.id, function (err) {\n        if (err) return next(err);\n        res.send('Deleted successfully!');\n    })\n};\n```\nThe function simply deletes an existing product.\n\nNow let\u2019s head to Postman and try-out our new endpoint. Call the following URL *\"localhost:1234/products/**PRODUCT_ID**/delete\"*\n\nPRODUCT_ID is the id of the object we\u2019ve created in the previous endpoint. You should get this from your database.\n\nWe get a success message stating \u2018Deleted successfully\u2019 in the body of our response.\n___\nDone \ud83c\udf89 \ud83c\udf89\nBy now, we are done with creating a full API which does the four operations (CRUD)\n\n***We did this project together, but do not be afraid if this was easy for you, which makes sense since we did it together. We are only setting grounds for building MERN applications once we learn REACT, in the next lesson. cant wait!***"}