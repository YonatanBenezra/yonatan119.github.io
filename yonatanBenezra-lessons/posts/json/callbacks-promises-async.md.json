{"layout": "post", "title": "Callbacks Promises and Async", "published": "Apr 27, 2021", "author": "yonatanBenezra", "tags": "callbacks, promises, async", "timestamp": 1619526634, "location": "callbacks-promises-async.md.json", "content": "# Callbacks, Promises, and Async\n\n- **Synchronous** operations in JavaScript entails having each step of an operation waits for the previous step to execute completely.   \nThis means no matter how long a previous process takes, subsquent process won't kick off until the previous is completed.   \n- **Asynchronous** operations, on the other hand, defers operations.   \nAny process that takes a lot of time to process is usually run alongside other synchronous operation and completes in the future.\n___\n**Asynchronous Operations**\nOperations in JavaScript are traditionally synchronous and execute from top to bottom.   \nFor instance, a farming operation that logs farming process to the console:\n```javascript\n// JAVASCRIPT\n\nconsole.log(\"Plant corn\");\nconsole.log(\"Water plant\");\nconsole.log(\"Add fertilizer\");\n```\nIf we run the code above, we have the following logged in the console:\n```javascript\n// BASH\n\nPlant corn\nWater plant\nAdd fertilizer\n```\nNow let's change that a bit so that watering the farm take longer than planting and fertilizing:\n```javascript\n// JAVASCRIPT\n\nconsole.log(\"Plant maize\");\n\nsetTimeout(function() {\n  console.log(\"Water plant\")\n},3000);\n\nconsole.log(\"Add fertilizer\");\n```\nWe get the following in the console:\n```javascript\n// BASH\n\n    Plant Maize\n    Add fertilizer\n    Water plant\n```\n\nWhy? The **setTimeout** function makes the operation asynchronous by deferring plant watering to occur after 3 seconds.   \nThe whole operation doesn\u2019t pause for 3 seconds so it can log \u201cWater plant\u201d.    \nRather, the system goes ahead to apply fertilizers and then water plant after 3 seconds.\n___\n**Functions are First-Class Objects**\nIt's important to keep in mind before going through the rest of these lessons that JavaScript Functions are first-class objects in and as such can functions have the ability to:\n- Be assigned to variables (and treated as a value)\n- Have other functions in them\n- Return other functions to be called later\n___\n**Callback Functions**\nWhen a function simply accepts another function as an argument, this contained function is known as a callback function.   \nUsing callback functions is a core functional programming concept, and you can find them in most JavaScript code.   \nEither in simple functions like **setInterval**, event listening or when making API calls.\nCallback functions are written like so:\n```javascript\nsetInterval(function() {\n  console.log('hello!');\n}, 1000);\n```\nsetInterval accepts a callback function as its first parameter and also a time interval.   \nAnother example using .map();\n```javascript\nconst list    = ['man', 'woman', 'child']\n\n// create a new array\n// loop over the array and map the data to new content\nconst newList = list.map(function(val) {\n  return val + \" kind\";\n});\n\n// newList = ['man kind', 'woman kind', 'child kind']\n```\nIn the example above, we used the **.map()** method to iterate through the array list, the method accepts a callback function which states how each element of the array will be manipulated.   \nCallback functions can also accept arguments as well.\n___\n**Naming Callback functions**\nCallback functions can be named or be anonymous functions.   \nIn our first examples, we used anonymous callback functions.   \nLet\u2019s look at a named callback function:\n```javascript\nfunction greeting(name) {\n  console.log(`Hello ${name}, welcome to Presentense!`);\n}\n```\nThe above function is assigned a name **greeting** and has an argument of **name**. We're also using an ES6 template string. Let\u2019s use this function as a callback function.\n```javascript\nfunction introduction(firstName, lastName, callback) {\n  const fullName = `${firstName} ${lastName}`;\n\n  callback(fullName);\n}\n\nintroduction('Chris','Nwamba', greeting); // Hello Chris Nwamba, welcome to Presentense!\n```\nNotice the usage of the callback? The succeeding brackets, () after the function are not used when passing the function as a parameter.\n\n*Note: The callback function is not run unless called by its containing function, it is called back, that is why the term is **call back function***\n\nMultiple functions can be created independently and used as callback functions, these create multi-level functions.   \nWhen this function tree created becomes too large, the code becomes incomprehensible sometimes and is not easily refactored.   \nThis is known as callback hell. Let\u2019s see an example:\n```javascript\n// a bunch of functions are defined up here\n\n// lets use our functions in callback hell\nfunction setInfo(name) {\n  address(myAddress) {\n    officeAddress(myOfficeAddress) {\n      telephoneNumber(myTelephoneNumber) {\n        nextOfKin(myNextOfKin) {\n          console.log('done'); //let's begin to close each function! \n        };\n      };\n    };\n  };\n}\n```\nWe are assuming these functions have been previously defined elsewhere.   \nYou can see how confusing it is to pass each function as callbacks.   \nCallback functions are useful for short asynchronous operations. When working with large sets, this is not considered best practice.   \nBecause of this challenge, Promises were introduced to simplify deferred activities.\n___\n**Promises**\nI promise to do this whenever that is true. If it isn't true, then I won't.\n\nThis is a simple illustration of JavaScript Promises. Sounds like an IF statement? We\u2019ll soon see a difference.\n\nA promise is used to handle the asynchronous result of an operation.   \nJavaScript is designed not to wait for an asynchrnous block of code to completely execute before other synchronous parts of the code can run.   \nFor instance, when making API requests to servers, we have no idea if these servers are offline or online, or how long it takes to process the server request.\n\nWith Promises, we can defer execution of a code block until an async request is completed. This way, other operations can keep running without interruption.\n\n*Promises have three states:*\n\n- **Pending**: This is the initial state of the Promise before an operation begins\n- **Fulfilled**: This means the specified operation was completed\n- **Rejected**: The operation did not complete; an error value is usually thrown\n___\n**Creating a Promise**\nThe Promise object is created using the **new** keyword and contains the promise; this is an executor function which has a resolve and a reject callback.   \nAs the names imply, each of these callbacks returns a value with the reject callback returning an error object.\n```javascript\n// JAVASCRIPT\n\nconst promise = new Promise(function(resolve, reject) {\n  // promise description\n})\n```\nLet\u2019s create a promise:\n```javascript\n// JAVASCRIPT\nconst weather = true\nconst date    = new Promise(function(resolve, reject) {\n  if (weather) {\n    const dateDetails = {\n      name:     'Cubana Restaurant',\n      location: '55th Street',\n      table:    5\n    };\n\n    resolve(dateDetails)\n  } else {\n    reject(new Error('Bad weather, so no Date'))\n  }\n});\n```\nIf *weather* is true, resolve the promise returning the data *dateDetails*,   \nelse return an error object with data *Bad weather, so no Date*.\n___\n**Using Promises**\nUsing a promise that has been created is relatively straightforward; we chain **.then()** and **.catch(**) to our Promise like so:\n```javascript\n// JAVASCRIPT\n\ndate\n  .then(function(done) {\n    // the content from the resolve() is here\n  })\n  .catch(function(error) {\n    // the info from the reject() is here\n  });\n```\nUsing the promise we created above, let's take this a step further:\n```javascript\n// JAVASCRIPT\n\nconst myDate = function() {\n  date\n    .then(function(done) {\n      console.log('We are going on a date!')\n      console.log(done)\n    })\n    .catch(function(error) {\n        console.log(error.message)\n    })\n}\n\nmyDate();\n```\nSince the weather value is true, we call **mydate()** and our console logs read:\n```javascript\n// JAVASCRIPT\n\nWe are going on a date!\n{\n  name: 'Cubana Restaurant',\n  location: '55th Street'\n  table: 5\n}\n```\n\n*.then()* receives a function with an argument which is the resolve value of our promise.   \n*.catch* returns the reject value of our promise.\n\n*Note: Promises are asynchronous.   \nPromises in functions are placed in a micro-task queue and run when other synchronous operations complete.*\n___\n**Chaining Promises**\nSometimes we may need to execute two or more asynchronous operations based on the result of preceding promises.   \nIn this case, promises are chained.   \nStill using our created promise, let\u2019s order an uber if we are going on a date.\n\nSo we create another promise:\n```javascript\n// JAVASCRIPT\n\nconst orderUber = function(dateDetails) {\n  return new Promise(function(resolve, reject) {\n    const message = `Get me an Uber ASAP to ${dateDetails.location}, we are going on a date!`;\n\n    resolve(message)\n  });\n}\n```\nThis promise can be shortened to:\n```javascript\n// JAVASCRIPT\n\nconst orderUber = function(dateDetails) {\n  const message = `Get me an Uber ASAP to ${dateDetails.location}, we are going on a date!`;\n  return Promise.resolve(message)\n} \n```\nWe chain this promise to our earlier *date* operation like so:\n```javascript\n// JAVASCRIPT\n\nconst myDate = function() {\n  date\n    .then(orderUber)\n    .then(function(done) {\n      console.log(done);\n    })\n    .catch(function(error) {\n      console.log(error.message)\n    })\n}\n\nmyDate();\n```\nSince our weather is *true*, the output to our console is:\n```javascript\n// JAVASCRIPT\n\nGet me an Uber ASAP to 55th Street, we are going on a date!\n```\nOnce the *orderUber* promise is chained with *.then*, subsequent *.then* utilizes data from the previous one.\n___\n**Async and Await**\nAn async function is a modification to the syntax used in writing promises.   \nIt only makes writing promises easier.\n\nAn async function returns a promise -- if the function returns a value, the promise will be resolved with the value, but if the async function throws an error, the promise is rejected with that value. Let\u2019s see an async function:\n```javascript\n// JAVASCRIPT\n\nasync function myRide() {\n  return '2017 Dodge Charger';\n}\n```\nand a different function that does the same thing but in promise format:\n```javascript\n// JAVASCRIPT\n\nfunction yourRide() {\n  return Promise.resolve('2017 Dodge Charger');\n}\n```\nFrom the above statements, *myRide()* and *yourRide()* are equal and will both resolve to \"2017 Dodge Charger\". Also when a promise is rejected, an async function is represented like this:\n```javascript\n// JAVASCRIPT\n\nfunction foo() {\n  return Promise.reject(25)\n}\n\n// is equal to\nasync function() {\n  throw 25;\n}\n```\n___\n**Await**\nAwait is only used with an **async function**.   \nThe await keyword is used in an async function to ensure that all promises returned in the async function are synchronized, meaning, they wait for each other.   \nAwait eliminates the use of callbacks in *.then()* and *.catch()*.   \nIn using async and await, async is prepended when returning a promise, await is prepended when calling a promise. try and catch are also used to get the rejection value of an async function. Let's see this with our date example:\n```javascript\n// JAVASCRIPT\n\nasync function myDate() {\n  try {\n\n    let dateDetails = await date;\n    let message     = await orderUber(dateDetails);\n    console.log(message);\n\n  } catch(error) {\n    console.log(error.message);\n  }\n}\n```\nLastly we call our async function:\n```javascript\n// JAVASCRIPT\n\n(async () => { \n  await myDate();\n})();\n```\nThis is an arrow function syntax.\n___\n**Conclusion**\nUnderstanding the concepts of Callbacks, Promises, and Async/Await can be rather confusing, but so far we have seen how they work when carrying out asynchronous operations in JavaScript.\nThey come in handy a lot when making API requests and event handling. You can learn more about using [promises here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises) and [async functions here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).\n___"}