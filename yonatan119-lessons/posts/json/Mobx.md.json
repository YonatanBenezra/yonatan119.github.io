{"layout": "post", "title": "Mobx", "published": "May 04, 2021", "author": "yonatan119", "tags": "Store, Mobx", "timestamp": 1620135034, "location": "Mobx.md.json", "content": "**Introduction to MobX**  \nMobX is an open source state management tool. When creating a web application, developers often seek an effective way of managing state within their applications.  \nThe solution we will learn in this course is called MobX, a simple, scalable, and standalone state management library.  \n*According to the MobX getting started page, \u201cMobX makes state management simple again by addressing the root issue: it makes it impossible to produce an inconsistent state.\u201d*\n\nMobX is standalone and does not depend on any frontend library or framework to work. There are implementations of the MobX in popular front-end frameworks like React.\n___\n**MobX: Core concepts**\nIn addition to being a library, MobX also introduces a few concepts: \n- state\n- actions\n- derivations (including reactions and computed values).\n\nApplication state refers to the entire model of an application, and can contain different data types including: \n- arrays.\n- numbers.\n- objects.\n In MobX, actions are methods that manipulate and update the state.  \n These methods can be bound to a JavaScript event handler to ensure a UI event triggers them.\n\nAnything (not just a value) that is derived from the application state without further interaction is referred to as a derivation. Derivations will listen to any particular state and then perform some computation to produce a distinct value from that state.  \n*A derivation can return any data type, including objects.* \nIn MobX, the two types of derivations are reactions and computed values.\n\nSometimes, when a state changes, there may be automatic side effects needed to update the state.  \nMobX refers to this as a reaction, and differentiates reactions from event handlers in the DOM.  \nReactions can make a remote network request, call the local storage, or even append a new DOM element on the fly.\n\nUnlike reactions, which do not necessarily return a value, computed value derivations always return a value derived from the current state.\n___\n**Demonstration: Using MobX to create a store**\nTo demonstrate how MobX works, we will create an example implementing a pet owner store.  \nTo begin, we will create a file named PetOwnerStore.js and inside create a basic representation of the store using a class that includes pets and owners as instance properties and initialized to an empty array.\n```javascript   \nclass PetOwnerStore {\n  pets = [];\n  owners = [];\n}\n```\n___\n**Create new items**\nIdeally, we want our store to be able to create a new pet and new owner.  \nFor this, we will introduce two methods to the store: \n- createPet, which accepts a pet object and pushes it into the pet array of the current instance.\n- createOwner, which takes an owner object and pushes it to the end of the owner array of the current instance\n\n```javascript\nclass PetOwnerStore {\n  pets = [];\n  owners = [];\n\n  createPet(pet = { id: 0, name: \"\", type: \"\", breed: \"\", owner: null }) {\n    this.pets.push(pet);\n  }\n\n  createOwner(owner = { id: 0, firstName: \"\", lastName: \"\" }) {\n    this.owners.push(owner);\n  }\n}\n```\n___\n**Automatically update items**\nWe also want to be able to automatically update store items.  \nTo do this, we will introduce two more methods:\n- updateOwner to update an owner using an id\n- updatePet to update a pet using an id.\n```javascript\nclass PetOwnerStore {\n  pets = [];\n  owners = [];\n\n    // ...create pet\n\n    // ...create owner\n\n    // update owner\n  updateOwner(ownerId, update) {\n    const ownerIndexAtId = this.owners.findIndex((owner) => owner.id === ownerId);\n    if (ownerIndexAtId > -1 && update) {\n      this.owners[ownerIndexAtId] = update;\n    }\n  }\n\n    // update pet\n  updatePet(petId, update) {\n    const petIndexAtId = this.pets.findIndex((pet) => pet.id === petId);\n    if (petIndexAtId > -1 && update) {\n      this.pets[petIndexAtId] = update;\n    }\n  }\n}\n```\n___\n**Remove items**\nSimilarly, we want to be able to remove owners or pets from our store:\n```javascript\nclass PetOwnerStore {\n  pets = [];\n  owners = [];\n\n  // ...create pet\n\n    // ...create owner\n\n  // ...update pet\n\n    // ...update owner\n\n  // delete pet by user id\n  deletePet(petId) {\n    const petIndexAtId = this.pets.findIndex((pet) => pet.id === petId);\n    if (petIndexAtId > -1) {\n      this.pets.splice(petIndexAtId, 1)\n    }\n  }\n\n    // delete owner by owner id\n  deleteOwner(ownerId) {\n    const ownerIndexAtId = this.owners.findIndex((owner) => owner.id === ownerId);\n    if (ownerIndexAtId > -1) {\n      this.owners.splice(ownerIndexAtId, 1)\n    }\n  }\n}\n```\n___\n**Grant access for get**\nWe will also need to grant access to GET\n- totalOwners\n- totalPets\n- getPetsByOwner\n```javascript\nclass PetOwnerStore {\n\n  pets = [];\n  owners = [];\n\n    // total number owners\n  get totalOwners() {\n    return this.owners.length;\n  }\n\n    // total number of pets\n  get totalPets() {\n    return this.pets.length;\n  }\n\n    // Get pets using ownerId\n  getPetsByOwner(ownerId) {\n    return this.pets.filter((pet) => {\n      return pet.owner && pet.owner.id === ownerId;\n    });\n  }\n\n    // ...create pet\n\n    // ...create owner\n\n  // ...update pet\n\n    // ...update owner\n\n  // ...delete pet by user id\n\n    // ...delete owner by owner id\n}\n```\n**Assign id**\nFinally, we want to assign an owner to a pet using **ownerId** and **petId**, and keep some details about our store updated using **${this.totalPets()} total pets and ${this.totalOwners()}** as a string:\n```javascript\nclass PetOwnerStore {\n\n  pets = [];\n  owners = [];\n\n  // ... total number owners\n\n  // ... total number of pets\n\n  // ... Get pets using ownerId\n\n    // ...create pet\n\n    // ...create owner\n\n  // ...update pet\n\n    // ...update owner\n\n  // ...delete pet by user id\n\n    // ...delete owner by owner id\n\n  // assign an owner using ownerId to a pet using petId\n  assignOwnerToPet(ownerId, petId) {\n    const petIndexAtId = this.pets.findIndex((pet) => pet.id === petId);\n    const ownerIndexAtId = this.owners.findIndex((pet) => pet.id === ownerId);\n    if (petIndexAtId > -1 && ownerIndexAtId > -1) {\n      this.pets[petIndexAtId].owner = this.owners[petIndexAtId];\n    }\n  }\n\n    // get store details\n    get storeDetails () {\n    return `We have ${this.totalPets()} total pets and ${this.totalOwners()} total owners, so far!!!`\n  }\n\n    // Log the store details to the console\n  logStoreDetails() {\n    console.log(this.storeDetails);\n  }\n}\n```\n___\n**Final implementation**\nWhen completed, the final implementation of the store should look like this:\n```javascript\nclass PetOwnerStore {\n\n  pets = [];\n  owners = [];\n\n    // total number owners\n  get totalOwners() {\n    return this.owners.length;\n  }\n\n    // total number of pets\n  get totalPets() {\n    return this.pets.length;\n  }\n\n    // Get pets using ownerId\n  getPetsByOwner(ownerId) {\n    return this.pets.filter((pet) => {\n      return pet.owner && pet.owner.id === ownerId;\n    });\n  }\n\n  createPet(pet = { id: 0, name: \"\", type: \"\", breed: \"\", owner: null }) {\n    this.pets.push(pet);\n  }\n\n  createOwner(owner = { id: 0, firstName: \"\", lastName: \"\" }) {\n    this.owners.push(owner);\n  }\n\n  updateOwner(ownerId, update) {\n    const ownerIndexAtId = this.owners.findIndex((pet) => owner.id === ownerId);\n    if (ownerIndexAtId > -1 && update) {\n      this.owners[ownerIndexAtId] = update;\n    }\n  }\n\n  updatePet(petId, update) {\n    const petIndexAtId = this.pets.findIndex((pet) => pet.id === petId);\n    if (petIndexAtId > -1 && update) {\n      this.pets[petIndexAtId] = update;\n    }\n  }\n\n  deletePet(petId) {\n    const petIndexAtId = this.pets.findIndex((pet) => pet.id === petId);\n    if (petIndexAtId > -1) {\n      this.pets.splice(petIndexAtId, 1)\n    }\n  }\n\n  deleteOwner(ownerId) {\n    const ownerIndexAtId = this.owners.findIndex((owner) => owner.id === ownerId);\n    if (ownerIndexAtId > -1) {\n      this.owners.splice(ownerIndexAtId, 1)\n    }\n  }\n\n  // assign an owner using ownerId to a pet using petId\n  assignOwnerToPet(ownerId, petId) {\n    const petIndexAtId = this.pets.findIndex((pet) => pet.id === petId);\n    const ownerIndexAtId = this.owners.findIndex((pet) => pet.id === ownerId);\n    if (petIndexAtId > -1 && ownerIndexAtId > -1) {\n      this.pets[petIndexAtId].owner = this.owners[petIndexAtId];\n    }\n  }\n\n    get storeDetails () {\n    return `We have ${this.totalPets()} total pets and ${this.totalOwners()} total owners, so far!!!`\n  }\n\n  logStoreDetails() {\n    console.log(this.storeDetails);\n  }\n}\n```\n___\n**Initialize storefront**\nTo see the store in action, we will initialize it just as we would initialize regular JavaScript classes. After the initialization, we can interface with the store using the methods indicated.\n\nFor our example, we will add new pets and owners to the store and log the details we have so far:\n```javascript\nconst petOwnerStore = new PetOwnerStore();\n\n  petOwnerStore.createPet({\n    id: 1,\n    name: \"Bingo\",\n    type: \"Dog\",\n    breed: \"alsertian\",\n  });\n  petOwnerStore.createPet({\n    id: 2,\n    name: \"Lloyd\",\n    type: \"Cat\",\n    breed: \"winky\",\n  });\n  petOwnerStore.createOwner({ id: 1, firstName: \"Yonatan\", lastName: \"Benezra\" });\n\n  petOwnerStore.logStoreDetails(); // -> We have 2 pets and 1 owners, so far!!!\n```\n___\n**Making our MobX store reactive**\nAs discussed earlier, the MobX store should be reactive, and therefore respond to changes.  \nWe can test this by implementing the **makeObservable** function provided by the MobX library:\n```javascript\nimport { makeObservable } from \"mobx\";\n```\nThe **makeObservable** function turns a class into an observable state, which refreshes and updates itself whenever parts of its fields change.  \nThe **makeObservable** export from MobX library accepts two parameters: a reference to a class instance, and an object configuration of the class instance methods and fields.\n\nTo assist in making a store observable, here are some MobX config options:\n\n- Make any field value of the store that holds a primitive, an array, or an object an **observable**, with [different ways of creating an observable](https://mobx.js.org/api.html#creating-observables) based on the type of the value.\n- Decorate methods with **action** to be imported as a named export from the MobX library, using \n ```javascript\n import {action} from \"mobx\"\n ```\n . MobX also ships with other action [types](https://mobx.js.org/api.html#actions).\n- Configure functions that return a value based on the store\u2019s current state (a.k.a. derivations) as **computed**.\n- Configure reactions (functions that run in current state but do not return a value) as **autorun**.  \nView other options for reactions [here](https://mobx.js.org/api.html#reactions).\n___\n**Making our MobX store observable**\nTo make our **PetOwnerStore** class observable, we will begin by introducing a constructor to our store that will hold the configuration that makes the store reactive:\n```javascript\nclass PetOwnerStore {\n  pets = [];\n  owners = [];\n\n  constructor () {\n    makeObservable(this, {\n      pets: observable,\n      owners: observable,\n      totalOwners: computed,\n      totalPets: computed,\n      storeDetails: computed,\n      getPetsByOwner: action,\n      createPet: action,\n      createOwner: action,\n      updatePet: action,\n      updateOwner: action,\n      deletePet: action,\n      deleteOwner: action,\n      assignOwnerToPet: action\n    });\n    autorun(logStoreDetails);\n  }\n\n    // ... remaining store implementation\n}\n```\nAs you will notice, we have marked pets and owners as observable to keep our store interface updated as values are changed.\n\nWe have also marked:\n- totalOwners\n- totalPets\n- storeDetails\nas **computed** to allow for caching when these values are updated and returned.  \nAdditionally, we have marked:\n- createPet\n- createOwner\n- updatePet\n- updateOwner\n- deletePet\n- deleteOwner\n- assignownerToPet\nas action to account for state modifications.\n\n*Note, **logStoreDetails** will be run as a reaction since it logs the store details, but returns no value.*\n___\n**Registering and interacting with our MobX store**\nWe can apply the reactive store by creating a new instance of the store using the new operator just as we did with the non-reactive store.\n```javascript\nconst petOwnerStore = new PetOwnerStore();\n// -> We have 0 pets and 0 owners, so far!!!\n```\nMobX invokes reactions during initialization and whenever there is an update to the store, which means the logStoreDetails reaction function will rub after every initialization.\n\nNow, we can interact with the store by creating new pets and owners. Notice that the reactions are getting logged:\n```javascript\nconst petOwnerStore = new PetOwnerStore();\n// -> We have 0 pets and 0 owners, so far!!!\n\npetOwnerStore.createPet({\n  id: 1,\n  name: \"Bingo\",\n  type: \"Dog\",\n  breed: \"alsertian\",\n});\n// -> We have 1 pets and 0 owners, so far!!!\n\npetOwnerStore.createPet({\n  id: 2,\n  name: \"Lloyd\",\n  type: \"Cat\",\n  breed: \"winky\",\n});\n// -> We have 2 pets and 0 owners, so far!!!\npetOwnerStore.createOwner({ id: 1, firstName: \"Yonatan\", lastName: \"Benezra\" });\n// -> We have 2 pets and 1 owners, so far!!!\n```\n___\n**Managing frontend with MobX and React**\nNow it\u2019s time to add some frontend to our store with React!\n\n**Create a new React app**\nlets run:\n```javascript\nnpx create-react-app mobx-react\n```\nTo make it easier to access the PetOwner store, we will create a new file and name it PetOwnerStore.js in the src folder and load it with the content of our PetOwner MobX store.  \nLets copy all the code we wrote in our mobx store to this file.  \nNow, inside of the src folder, we can create a folder for our components and inside create a PetList component\n```javascript\ncd src\nmkdir components\ntouch components/PetList.jsx\n```\n___\n**Manage components**\nFirst, let\u2019s make the PetList component show the details of the store:\n```javascript\n// src/components/Petlist.jsx\n\nimport React from \"react\";\n\nfunction PetList({ store }) {\n  return <div>{store.storeDetails}</div>;\n}\n\nexport default PetList;\n```\nInside of App.jsx, we will import the PetList component and pass the store object to it as a prop, after which our App.jsx component will look like this:\n```javascript\n// src/App.js\nimport PetOwnerStore from \"./PetOwnerStore\";\nimport PetList from \"./components/PetList\";\n\nfunction App() {\n  const store = new PetOwnerStore();\n  return (\n    <div className=\"App\">\n      <PetList store={store} />\n    </div>\n  );\n}\n\nexport default App;\n```\n___\n**Modify components and add details**\nNext, we will modify the PetList.jsx component to add a new pet to our list.  \nFor this, we will add a button and and assign it to the onClick event:\n```javascript\n// src/components/Petlist.jsx\n\nfunction PetList({ store }) {\n  const handleAddPet = () => {};\n\n  return (\n    <div>\n      {store.storeDetails}\n      <button onClick={handleAddPet}>+ New pet</button>\n    </div>\n  );\n}\n```\nWe can now update the handleAddPet function to collect details from the user and call the store\u2019s createPet method to add the pet to the pets array inside the store:\n```javascript\n// src/components/Petlist.jsx\n\nconst handleAddPet = () => {\n  const name = prompt(\"Name of the pet\");\n  const type = prompt(\"Type of the pet\");\n  const breed = prompt(\"Breed of the pet\");\n  const ownerId = prompt(\"Owner's Id of the pet\");\n\n  const pet = store.createPet({ id: Date.now(), name, breed, type });\n  store.assignOwnerToPet(ownerId, pet.id);\n};\n```\nAt this point, you should notice that when we try to run this with our console in view, the store is updated, but the component did not receive the new data.  \nWe will address this in the following section.\n___\n**Making React components observable**\nWe can solve the above issue by making React components aware of updates in the store to trigger a rerender of components.  \nThe PetList component can become observable with the help mobx-react-lite package.\n___\n**Install mobx-react-lite**\nTo start, we will install mobx-react-lite using npm:\n```javascript\nnpm install mobx-react-lite --save\n```\n___\n**Import observer**\nInside of the PetList component, import observer from mobx-react-lite; then wrap the PetList component with it:\n```javascript\n// src/components/Petlist.jsx\n\nimport React from \"react\";\nimport { observer } from \"mobx-react-lite\";\n\nfunction PetList({ store }) {\n  const handleAddPet = () => {\n    const name = prompt(\"Name of the pet\");\n    const type = prompt(\"Type of the pet\");\n    const breed = prompt(\"Breed of the pet\");\n    const ownerId = prompt(\"Owner's Id of the pet\");\n\n    const pet = store.createPet({ id: Date.now(), name, breed, type });\n    store.assignOwnerToPet(ownerId, pet.id);\n  };\n\n  return (\n    <div>\n      {store.storeDetails}\n      <p>\n        <button onClick={handleAddPet}>+ New pet</button>\n      </p>\n    </div>\n  );\n}\n\nexport default observer(PetList);\n```\nBy wrapping the component with an observer, it will now automatically become aware of changes in the store. Now, we can create a new pet and have the component rerendered:  \nNow that MobX can interact with our application, in the following sections, we will discuss how to list a pet item, update an item, and delete an item.\n___\n**List items in state**\nUsing MobX and React, we can create a table to list the items in the pets state and buttons to update and delete pet items from the store:\n```javascript\n// src/components/Petlist.jsx\n\n<p>{store.storeDetails}</p>\n<table>\n  <thead>\n    <tr>\n      <th>##</th>\n      <th>Pet Name</th>\n      <th>Pet Type</th>\n      <th>Pet Breed</th>\n      <th>Owner</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    {store.pets.map((pet) => {\n      return (\n        <tr key={pet.id}>\n          <td>{pet.id}</td>\n          <td>{pet.name}</td>\n          <td>{pet.type}</td>\n          <td>{pet.breed}</td>\n          <td>\n            {pet.owner\n              ? `${pet.owner?.firstName} ${pet.owner?.lastName}`\n              : \"---\"}\n          </td>\n          <td>\n            <button\n              onClick={() => handleDeletePet(pet)}\n              style={{ marginRight: \"1rem\" }}\n            >\n              Delete {pet.name}\n            </button>\n            <button onClick={() => handleUpdatePet(pet)}>\n              Update {pet.name}\n            </button>\n          </td>\n        </tr>\n      );\n    })}\n  </tbody>\n</table>\n<button onClick={handleAddPet}>+ New pet</button>\n```\n___\n**Edit items**\nWe can edit items, such as a pet, by implementing the handleUpdate function that we have provided when listing pets.\n\nAt the top of the PetList component, we will add the below handleUpdatePet function:\n```javascript\nconst handleUpdatePet = (pet) => {\n  pet.name = prompt(\"Name of the pet\", pet.name);\n  pet.type = prompt(\"Type of the pet\", pet.type);\n  pet.breed = prompt(\"Breed of the pet\", pet.breed);\n  const ownerId = prompt(\"Owner's Id of the pet\", pet.owner?.id);\n  store.updatePet(pet.id, pet);\n  if (ownerId !== pet.owner?.id) {\n    store.assignOwnerToPet(ownerId, pet.id);\n  }\n};\n```\nThe function accepts a pet and uses a prompt to get the:\n- name\n- type\n- breed\n- ownerId\nbefore it calls the updatePet function on the store, passing the modified pet object.  \nIf we have a new ownerId, we will be assigning the pet to the owner by calling the **assignOwnerToPet** method on the store instance.\n___\n**Deleting items**\nTo delete an item, we can implement the **handleDelete** function on a pet item on the list.  \nThe function will accept a pet object and call **store.deletePet** to complete the process:\n```javascript\nconst handleDeletePet = (pet) => {\n  store.deletePet(pet.id);\n};\nFull code: Create, update, and delete\nBelow is the full code for the PetList component that makes it possible to create, update, and delete a store item:\n\nimport React from \"react\";\nimport { observer } from \"mobx-react-lite\";\n\nfunction PetList({ store }) {\n  const handleAddPet = () => {\n    const name = prompt(\"Name of the pet\");\n    const type = prompt(\"Type of the pet\");\n    const breed = prompt(\"Breed of the pet\");\n    const ownerId = prompt(\"Owner's Id of the pet\");\n\n    const pet = store.createPet({ id: Date.now(), name, breed, type });\n    store.assignOwnerToPet(ownerId, pet.id);\n  };\n\n  const handleUpdatePet = (pet) => {\n    pet.name = prompt(\"Name of the pet\", pet.name);\n    pet.type = prompt(\"Type of the pet\", pet.type);\n    pet.breed = prompt(\"Breed of the pet\", pet.breed);\n    const ownerId = prompt(\"Owner's Id of the pet\", pet.owner?.id);\n    store.updatePet(pet.id, pet);\n    if (ownerId !== pet.owner?.id) {\n      store.assignOwnerToPet(ownerId, pet.id);\n    }\n  };\n\n  const handleDeletePet = (pet) => {\n    store.deletePet(pet.id);\n  };\n\n  return (\n    <div>\n      <p>{store.storeDetails}</p>\n      <table>\n        <thead>\n          <tr>\n            <th>##</th>\n            <th>Pet Name</th>\n            <th>Pet Type</th>\n            <th>Pet Breed</th>\n            <th>Owner</th>\n            <th></th>\n          </tr>\n        </thead>\n        <tbody>\n          {store.pets.map((pet) => {\n            return (\n              <tr key={pet.id}>\n                <td>{pet.id}</td>\n                <td>{pet.name}</td>\n                <td>{pet.type}</td>\n                <td>{pet.breed}</td>\n                <td>\n                  {pet.owner\n                    ? `${pet.owner?.firstName} ${pet.owner?.lastName}`\n                    : \"---\"}\n                </td>\n                <td>\n                  <button\n                    onClick={() => handleDeletePet(pet)}\n                    style={{ marginRight: \"1rem\" }}\n                  >\n                    Delete {pet.name}\n                  </button>\n                  <button onClick={() => handleUpdatePet(pet)}>\n                    Update {pet.name}\n                  </button>\n                </td>\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n      <button onClick={handleAddPet}>+ New pet</button>\n    </div>\n  );\n}\n\nexport default observer(PetList);\n```\n___\nFinalizing our application\nFor our application to be complete, we need to:\n- create\n- update\n- delete owners\nTo start, we will create a new component, **OwnerList**, inside of the component folder.  \nThen, we will import the component inside of App.jsx in the application, passing it to the store as we have done for the PetList component:\n```javascript\nimport PetOwnerStore from \"./PetOwnerStore\";\nimport PetList from \"./components/PetList\";\nimport OwnerList from \"./components/OwnerList\";\nimport \"./App.css\";\n\nfunction App() {\n  const store = new PetOwnerStore();\n  return (\n    <div className=\"App\">\n      <h3>Pets List</h3>\n      <PetList store={store} />\n      <hr />\n      <h3>Owners List</h3>\n      <OwnerList store={store} />\n    </div>\n  );\n}\n\nexport default App;\n```\nNext, we will update the OwnerList component with the following code:\n```javascript\n// src/components/OwnerList.jsx\nimport { observer } from \"mobx-react-lite\";\nimport React from \"react\";\n\nfunction OwnerList({ store }) {\n  const handleAddOwner = () => {\n    const firstName = prompt(\"Firstname?\");\n    const lastName = prompt(\"Lastname?\");\n    store.createOwner({ id: Date.now(), firstName, lastName });\n  };\n\n  const handleUpdateOwner = (owner) => {\n    owner.firstName = prompt(\"Firstname?\", owner.firstName);\n    owner.lastName = prompt(\"Lastname?\", owner.lastName);\n    store.updateOwner(owner.id, owner);\n  };\n\n  const handleDeleteOwner = (owner) => {\n    store.deleteOwner(owner.id);\n  };\n\n  return (\n    <div className=\"pet-owner-app\">\n      <table>\n        <thead>\n          <tr>\n            <th>##</th>\n            <th>First Name</th>\n            <th>last Name</th>\n            <th>Owner</th>\n            <th></th>\n          </tr>\n        </thead>\n        <tbody>\n          {store.owners.map((owner) => {\n            return (\n              <tr key={owner.id}>\n                <td>{owner.id}</td>\n                <td>{owner.firstName}</td>\n                <td>{owner.lastName}</td>\n                <td>\n                  <button\n                    onClick={() => handleDeleteOwner(owner)}\n                    style={{ marginRight: \"1rem\" }}\n                  >\n                    Delete {owner.firstName}\n                  </button>\n                  <button onClick={() => handleUpdateOwner(owner)}>\n                    Update {owner.firstName}\n                  </button>\n                </td>\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n      <button onClick={handleAddOwner}>+ New owner</button>\n    </div>\n  );\n}\n\nexport default observer(OwnerList);\n```\nNote that the OwnerList component functions in the same way as the PetList component.  \nThe only difference here is that we are not assigning owners to pets as we have done with the PetList component.\n___\n**Using MobX to manage data from a remote server**\nMany times, data needs to be loaded from a remote server.  \nWe can simulate this by modifying **PetOwnerStore** and adding a **prefetchData** method at the end of the class.  \nWe will use a setTimeout to simulate a network request, then call the create methods on the class to add the newly available data into the store:\n```javascript\nclass PetOwnerStore {\n  // src/PetOwnerStore.js\n\n  // Other implemetations\n\n  prefetchData = () => {\n    const owners = [{ firstName: \"Yonatan\", lastName: \"Benezra\", id: 1 }];\n    const pets = [\n      {\n        id: 1,\n        name: \"Lincy\",\n        breed: \"Siamese\",\n        type: \"Cat\",\n        ownerId: 1,\n      },\n    ];\n\n    setTimeout(() => {\n      console.log(\"Fetch complete update store\");\n      owners.map((pet) => this.createOwner(pet));\n      pets.map((pet) => {\n        this.createPet(pet);\n        this.assignOwnerToPet(pet.ownerId, pet.id);\n        return pet;\n      });\n    }, 3000);\n  };\n}\n```\nIn the constructor, we will register this method as an action for MobX to manage for us.  \nSince we will need to fetch data as soon as we begin loading the app, we will call the method during the store\u2019s initialization.  \nTo do this, we will use **runInAction** as follows:\n```javascript\n// src/PetOwnerStore.js\n\nimport {\n  action,\n  computed,\n  makeObservable,\n  observable,\n  autorun,\n  runInAction,\n} from \"mobx\";\n\nclass PetOwnerStore {\n  pets = [];\n  owners = [];\n\n  constructor() {\n    makeObservable(this, {\n      pets: observable,\n      owners: observable,\n      totalOwners: computed,\n      totalPets: computed,\n      storeDetails: computed,\n      getPetsByOwner: action,\n      createPet: action,\n      createOwner: action,\n      updatePet: action,\n      updateOwner: action,\n      deletePet: action,\n      deleteOwner: action,\n      assignOwnerToPet: action,\n    });\n    autorun(this.logStoreDetails);\n    // A reaction that runs just once!\n    runInAction(this.prefetchData);\n  }\n\n  logStoreDetails = () => {\n    console.log(this.storeDetails);\n  };\n\n  prefetchData = () => {\n    const owners = [{ firstName: \"Aleem\", lastName: \"Isiaka\", id: 1 }];\n    const pets = [\n      {\n        id: 1,\n        name: \"Lincy\",\n        breed: \"Siamese\",\n        type: \"Cat\",\n        ownerId: 1,\n      },\n    ];\n\n    setTimeout(() => {\n      console.log(\"Fetch complete update store\");\n      owners.map((pet) => this.createOwner(pet));\n      pets.map((pet) => {\n        this.createPet(pet);\n        this.assignOwnerToPet(pet.ownerId, pet.id);\n        return pet;\n      });\n    }, 3000);\n  };\n}\n\nexport default PetOwnerStore;\n```\n___\nCongratulations! We have now created a complete PetOwner React/MobX app with CRUD functionalities.  \nIf you are having trouble, Contact your mentor or Me!\n\nNext step: Style it!\nMake this project something worth showing off on github!"}